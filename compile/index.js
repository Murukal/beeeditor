/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("react"), require("react-dom")) : factory(root["react"], root["react-dom"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, (__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@lexical/clipboard/LexicalClipboard.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst IGNORE_TAGS = new Set(['STYLE']);\nfunction getHtmlContent(editor) {\n  const selection$1 = lexical.$getSelection();\n\n  if (selection$1 == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection$1) && selection$1.isCollapsed() || selection$1.getNodes().length === 0) {\n    return null;\n  }\n\n  const state = selection.$cloneContents(selection$1);\n  return $convertSelectedLexicalContentToHtml(editor, selection$1, state);\n}\nfunction $convertSelectedLexicalNodeToHTMLElement(editor, selection, node) {\n  let nodeToConvert = node;\n\n  if (lexical.$isRangeSelection(selection) || lexical.$isGridSelection(selection)) {\n    const anchor = selection.anchor.getNode();\n    const focus = selection.focus.getNode();\n    const isAnchor = node.is(anchor);\n    const isFocus = node.is(focus);\n\n    if (lexical.$isTextNode(node) && (isAnchor || isFocus)) {\n      const anchorOffset = selection.anchor.getCharacterOffset();\n      const focusOffset = selection.focus.getCharacterOffset();\n      const isBackward = selection.isBackward();\n      const isSame = anchor.is(focus);\n      const isFirst = node.is(isBackward ? focus : anchor);\n      const nodeText = node.getTextContent();\n      const nodeTextLength = nodeText.length;\n\n      if (isSame) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = node.splitText(startOffset, endOffset);\n        nodeToConvert = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n      } else {\n        let endOffset;\n\n        if (isFirst) {\n          endOffset = isBackward ? focusOffset : anchorOffset;\n        } else {\n          endOffset = isBackward ? anchorOffset : focusOffset;\n        }\n\n        if (!isBackward && endOffset === 0) {\n          return null;\n        } else if (endOffset !== nodeTextLength) {\n          nodeToConvert = node.splitText(endOffset)[isFirst && endOffset !== 0 ? 1 : 0];\n        }\n      }\n    }\n  }\n\n  const {\n    element,\n    after\n  } = nodeToConvert.exportDOM(editor);\n  if (!element) return null;\n  const children = lexical.$isElementNode(nodeToConvert) ? nodeToConvert.getChildren() : [];\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n\n    if (childNode.isSelected()) {\n      const newElement = $convertSelectedLexicalNodeToHTMLElement(editor, selection, childNode);\n      if (newElement) element.append(newElement);\n    }\n  }\n\n  return after ? after.call(nodeToConvert, element) : element;\n}\nfunction $convertSelectedLexicalContentToHtml(editor, selection, state) {\n  const container = document.createElement('div');\n\n  for (let i = 0; i < state.range.length; i++) {\n    const nodeKey = state.range[i];\n    const node = lexical.$getNodeByKey(nodeKey);\n\n    if (node && node.isSelected()) {\n      const element = $convertSelectedLexicalNodeToHTMLElement(editor, selection, node);\n      if (element) container.append(element);\n    }\n  }\n\n  return container.innerHTML;\n}\nfunction $getLexicalContent(editor) {\n  const selection$1 = lexical.$getSelection();\n\n  if (selection$1 !== null) {\n    const namespace = editor._config.namespace;\n    const state = selection.$cloneContents(selection$1);\n    return JSON.stringify({\n      namespace,\n      state\n    });\n  }\n\n  return null;\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalNodesString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalNodesString) {\n    const namespace = editor._config.namespace;\n\n    try {\n      const lexicalClipboardData = JSON.parse(lexicalNodesString);\n\n      if (lexicalClipboardData.namespace === namespace) {\n        const nodeRange = lexicalClipboardData.state;\n        const nodes = $generateNodes(nodeRange);\n        selection.insertNodes(nodes);\n        return;\n      }\n    } catch (e) {// Malformed, missing nodes..\n    }\n  }\n\n  const textHtmlMimeType = 'text/html';\n  const htmlString = dataTransfer.getData(textHtmlMimeType);\n\n  if (htmlString) {\n    const parser = new DOMParser();\n    const dom = parser.parseFromString(htmlString, textHtmlMimeType);\n    const nodes = $generateNodesFromDOM(dom, editor); // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n\n    const topLevelBlocks = [];\n    let currentBlock = null;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (!lexical.$isElementNode(node) || node.isInline()) {\n        if (currentBlock === null) {\n          currentBlock = lexical.$createParagraphNode();\n          topLevelBlocks.push(currentBlock);\n        }\n\n        if (currentBlock !== null) {\n          currentBlock.append(node);\n        }\n      } else {\n        topLevelBlocks.push(node);\n        currentBlock = null;\n      }\n    }\n\n    selection.insertNodes(topLevelBlocks);\n    return;\n  }\n\n  $insertDataTransferForPlainText(dataTransfer, selection);\n}\n\nfunction $generateNodes(nodeRange) {\n  const {\n    range,\n    nodeMap\n  } = nodeRange;\n  const parsedNodeMap = new Map(nodeMap);\n  const nodes = [];\n\n  for (let i = 0; i < range.length; i++) {\n    const key = range[i];\n    const parsedNode = parsedNodeMap.get(key);\n\n    if (parsedNode !== undefined) {\n      const node = lexical.$createNodeFromParse(parsedNode, parsedNodeMap);\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    cachedConversions.forEach(cachedConversion => {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null) {\n        if (currentConversion === null || currentConversion.priority < domConversion.priority) {\n          currentConversion = domConversion;\n        }\n      }\n    });\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, forChildMap, currentLexicalNode));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nfunction $generateNodesFromDOM(dom, editor) {\n  let lexicalNodes = [];\n  const elements = dom.body ? Array.from(dom.body.childNodes) : [];\n  const elementsLength = elements.length;\n\n  for (let i = 0; i < elementsLength; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.getHtmlContent = getHtmlContent;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/clipboard/LexicalClipboard.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalClipboard =  true ? __webpack_require__(/*! ./LexicalClipboard.dev.js */ \"./node_modules/@lexical/clipboard/LexicalClipboard.dev.js\") : 0\nmodule.exports = LexicalClipboard;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/clipboard/LexicalClipboard.js?");

/***/ }),

/***/ "./node_modules/@lexical/code/LexicalCode.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar Prism = __webpack_require__(/*! prismjs/components/prism-core */ \"./node_modules/prismjs/components/prism-core.js\");\n__webpack_require__(/*! prismjs/components/prism-clike */ \"./node_modules/prismjs/components/prism-clike.js\");\n__webpack_require__(/*! prismjs/components/prism-javascript */ \"./node_modules/prismjs/components/prism-javascript.js\");\n__webpack_require__(/*! prismjs/components/prism-markup */ \"./node_modules/prismjs/components/prism-markup.js\");\n__webpack_require__(/*! prismjs/components/prism-markdown */ \"./node_modules/prismjs/components/prism-markdown.js\");\n__webpack_require__(/*! prismjs/components/prism-c */ \"./node_modules/prismjs/components/prism-c.js\");\n__webpack_require__(/*! prismjs/components/prism-css */ \"./node_modules/prismjs/components/prism-css.js\");\n__webpack_require__(/*! prismjs/components/prism-objectivec */ \"./node_modules/prismjs/components/prism-objectivec.js\");\n__webpack_require__(/*! prismjs/components/prism-sql */ \"./node_modules/prismjs/components/prism-sql.js\");\n__webpack_require__(/*! prismjs/components/prism-python */ \"./node_modules/prismjs/components/prism-python.js\");\n__webpack_require__(/*! prismjs/components/prism-rust */ \"./node_modules/prismjs/components/prism-rust.js\");\n__webpack_require__(/*! prismjs/components/prism-swift */ \"./node_modules/prismjs/components/prism-swift.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter( // Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\nclass CodeHighlightNode extends lexical.TextNode {\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n\n  static getType() {\n    return 'code-highlight';\n  }\n\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n\n  updateDOM( // $FlowFixMe\n  prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n\n    return update;\n  } // Prevent formatting (bold, underline, etc)\n\n\n  setFormat(format) {\n    return this.getWritable();\n  }\n\n}\n\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\n\nfunction $createCodeHighlightNode(text, highlightType) {\n  return new CodeHighlightNode(text, highlightType);\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\nclass CodeNode extends lexical.ElementNode {\n  static getType() {\n    return 'code';\n  }\n\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n\n  constructor(language, key) {\n    super(key);\n    this.__language = language;\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        // $FlowFixMe[incompatible-type] domNode is a <table> since we matched it by nodeName\n        const table = node;\n\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 4\n          };\n        }\n\n        return null;\n      },\n      td: node => {\n        // $FlowFixMe[incompatible-type] element is a <td> since we matched it by nodeName\n        const td = node; // $FlowFixMe[incompatible-type] we know this will be a table, or null.\n\n        const table = td.closest('table');\n\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 4\n          };\n        }\n\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 4\n          };\n        }\n\n        return null;\n      },\n      tr: node => {\n        // $FlowFixMe[incompatible-type] element is a <tr> since we matched it by nodeName\n        const tr = node; // $FlowFixMe[incompatible-type] we know this will be a table, or null.\n\n        const table = tr.closest('table');\n\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 4\n          };\n        }\n\n        return null;\n      }\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement);\n      return newElement;\n    } // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n\n\n    const anchor = selection.anchor.getNode();\n    const firstNode = getFirstCodeHighlightNodeOfLine(anchor);\n\n    if (firstNode != null) {\n      let leadingWhitespace = 0;\n      const firstNodeText = firstNode.getTextContent();\n\n      while (leadingWhitespace < firstNodeText.length && /[\\t ]/.test(firstNodeText[leadingWhitespace])) {\n        leadingWhitespace += 1;\n      }\n\n      if (leadingWhitespace > 0) {\n        const whitespace = firstNodeText.substring(0, leadingWhitespace);\n        const indentedChild = $createCodeHighlightNode(whitespace);\n        anchor.insertAfter(indentedChild);\n        selection.insertNodes([lexical.$createLineBreakNode()]);\n        indentedChild.select();\n        return indentedChild;\n      }\n    }\n\n    return null;\n  }\n\n  canInsertTab() {\n    return true;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language;\n  }\n\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n\n}\nfunction $createCodeNode(language) {\n  return new CodeNode(language);\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction getFirstCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  return currentNode;\n}\nfunction getLastCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  return currentNode;\n}\n\nfunction convertPreElement(domNode) {\n  return {\n    node: $createCodeNode()\n  };\n}\n\nfunction convertDivElement(domNode) {\n  // $FlowFixMe[incompatible-type] domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: isCodeElement(div) ? $createCodeNode() : null\n  };\n}\n\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\n\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\n\nfunction convertTableCellElement(domNode) {\n  // $FlowFixMe[incompatible-type] domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\n\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\n\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\n\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\nfunction textNodeTransform(node, editor) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\n\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n\n  if (codeElement === null) {\n    return;\n  }\n\n  const children = node.getChildren();\n  const childrenLength = children.length; // $FlowFixMe: internal field\n\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  } // $FlowFixMe: internal field\n\n\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n\n  codeElement.setAttribute('data-gutter', gutter);\n} // Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra flag (`isHighlighting`) since both CodeNode and CodeHighlightNode\n// trasnforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\n\nlet isHighlighting = false;\n\nfunction codeNodeTransform(node, editor) {\n  if (isHighlighting) {\n    return;\n  }\n\n  isHighlighting = true; // When new code block inserted it might not have language selected\n\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(DEFAULT_CODE_LANGUAGE);\n  } // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n\n\n  editor.update(() => {\n    updateAndRetainSelection(node, () => {\n      const code = node.getTextContent();\n      const tokens = Prism.tokenize(code, Prism.languages[node.getLanguage() || ''] || Prism.languages[DEFAULT_CODE_LANGUAGE]);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(node.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      isHighlighting = false;\n    },\n    skipTransforms: true\n  });\n}\n\nfunction getHighlightNodes(tokens) {\n  const nodes = [];\n  tokens.forEach(token => {\n    if (typeof token === 'string') {\n      const partials = token.split('\\n');\n\n      for (let i = 0; i < partials.length; i++) {\n        const text = partials[i];\n\n        if (text.length) {\n          nodes.push($createCodeHighlightNode(text));\n        }\n\n        if (i < partials.length - 1) {\n          nodes.push(lexical.$createLineBreakNode());\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n\n      if (typeof content === 'string') {\n        nodes.push($createCodeHighlightNode(content, token.type));\n      } else if (content.length === 1 && typeof content[0] === 'string') {\n        nodes.push($createCodeHighlightNode(content[0], token.type));\n      } else {\n        nodes.push(...getHighlightNodes(content));\n      }\n    }\n  });\n  return nodes;\n} // Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\n\n\nfunction updateAndRetainSelection(node, updateFn) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.anchor) {\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + (lexical.$isLineBreakNode(_node) ? 0 : _node.getTextContentSize());\n    }, 0);\n  }\n\n  const hasChanges = updateFn();\n\n  if (!hasChanges) {\n    return;\n  } // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n\n\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  } // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n\n\n  node.getChildren().some(_node => {\n    if (lexical.$isTextNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n\n      if (textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n\n        return true;\n      }\n\n      textOffset -= textContentSize;\n    }\n\n    return false;\n  });\n} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\n\n\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n\n    leadingMatch++;\n  }\n\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\n\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {\n    return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;\n  }\n\n  if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {\n    return false;\n  } // Only run multiline indent logic on selections exclusively composed of code highlights and linebreaks\n\n\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);\n\n  if (startOfLine != null) {\n    doIndent(startOfLine, type);\n  }\n\n  for (let i = 1; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {\n      doIndent(node, type);\n    }\n  }\n\n  return true;\n}\n\nfunction doIndent(node, type) {\n  const text = node.getTextContent();\n\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    // If the codeblock node doesn't start with whitespace, we don't want to\n    // naively prepend a '\\t'; Prism will then mangle all of our nodes when\n    // it separates the whitespace from the first non-whitespace node. This\n    // will lead to selection bugs when indenting lines that previously\n    // didn't start with a whitespace character\n    if (text.length > 0 && /\\s/.test(text[0])) {\n      node.setTextContent('\\t' + text);\n    } else {\n      const indentNode = $createCodeHighlightNode('\\t');\n      node.insertBefore(indentNode);\n    }\n  } else {\n    if (text.indexOf('\\t') === 0) {\n      // Same as above - if we leave empty text nodes lying around, the resulting\n      // selection will be mangled\n      if (text.length === 1) {\n        node.remove();\n      } else {\n        node.setTextContent(text.substring(1));\n      }\n    }\n  }\n}\n\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock\n\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  const start = getFirstCodeHighlightNodeOfLine(anchorNode);\n  const end = getLastCodeHighlightNodeOfLine(focusNode);\n\n  if (start == null || end == null) {\n    return false;\n  }\n\n  const range = start.getNodesBetween(end);\n\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  } // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n\n\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n\n  if (sibling == null) {\n    return true;\n  }\n\n  const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\n\nfunction registerCodeHighlighting(editor) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW));\n}\n\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;\nexports.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;\nexports.registerCodeHighlighting = registerCodeHighlighting;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/code/LexicalCode.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/code/LexicalCode.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalCode =  true ? __webpack_require__(/*! ./LexicalCode.dev.js */ \"./node_modules/@lexical/code/LexicalCode.dev.js\") : 0\nmodule.exports = LexicalCode;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/code/LexicalCode.js?");

/***/ }),

/***/ "./node_modules/@lexical/dragon/LexicalDragon.dev.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction registerDragonSupport(editor) {\n  const handler = event => {\n    const rootElement = editor.getRootElement();\n\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n\n    const data = event.data;\n\n    if (typeof data === 'string') {\n      let parsedData;\n\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args; // TODO: we should probably handle formatCommand somehow?\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength; // If the offset is more than the end, make it the end\n\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize(); // If the offset is more than the end, make it the end\n\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                } // block the chrome extension from handling this event\n\n\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexports.registerDragonSupport = registerDragonSupport;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/dragon/LexicalDragon.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/dragon/LexicalDragon.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalDragon =  true ? __webpack_require__(/*! ./LexicalDragon.dev.js */ \"./node_modules/@lexical/dragon/LexicalDragon.dev.js\") : 0\nmodule.exports = LexicalDragon;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/dragon/LexicalDragon.js?");

/***/ }),

/***/ "./node_modules/@lexical/history/LexicalHistory.dev.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\n\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n\n    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0) {\n    return OTHER;\n  }\n\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n\n  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  } // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n\n\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n\n    return OTHER;\n  }\n\n  const nextDirtyNode = dirtyNodes[0];\n\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n\n  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n\n  if (prevText === nextText) {\n    return OTHER;\n  }\n\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n\n  return OTHER;\n}\n\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now(); // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n\n    const mergeAction = (() => {\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && tags.has('history-merge');\n\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n\n      const selection = nextEditorState._selection;\n      const prevSelection = prevEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n\n      if (!hasDirtyNodes) {\n        if (prevSelection === null && selection !== null) {\n          return HISTORY_MERGE;\n        }\n\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      return HISTORY_PUSH;\n    })();\n\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\n\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n    }\n\n    const historyStateEntry = redoStack.pop();\n\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry;\n    historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n      tag: 'historic'\n    });\n  }\n}\n\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);\n    }\n\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry;\n    historyStateEntry.editor.setEditorState(historyStateEntry.editorState.clone(historyStateEntry.undoSelection), {\n      tag: 'historic'\n    });\n  }\n}\n\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n      }\n\n      if (current !== null) {\n        undoStack.push({ ...current,\n          undoSelection: prevEditorState.read(lexical.$getSelection)\n        });\n        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    } // Else we merge\n\n\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n\n  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\n  return () => {\n    unregisterCommandListener();\n    unregisterUpdateListener();\n  };\n}\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexports.createEmptyHistoryState = createEmptyHistoryState;\nexports.registerHistory = registerHistory;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/history/LexicalHistory.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/history/LexicalHistory.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHistory =  true ? __webpack_require__(/*! ./LexicalHistory.dev.js */ \"./node_modules/@lexical/history/LexicalHistory.dev.js\") : 0\nmodule.exports = LexicalHistory;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/history/LexicalHistory.js?");

/***/ }),

/***/ "./node_modules/@lexical/link/LexicalLink.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass LinkNode extends lexical.ElementNode {\n  static getType() {\n    return 'link';\n  }\n\n  static clone(node) {\n    return new LinkNode(node.__url, node.__key);\n  }\n\n  constructor(url, key) {\n    super(key);\n    this.__url = url;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.__url;\n    utils.addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n\n  updateDOM( // $FlowFixMe: not sure how to fix this\n  prevNode, dom, config) {\n    // $FlowFixMe: not sure how to fix this\n    const anchor = dom;\n    const url = this.__url;\n\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n\n  getURL() {\n    return this.getLatest().__url;\n  }\n\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n\n  insertNewAfter(selection) {\n    const element = this.getParentOrThrow().insertNewAfter(selection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createLinkNode(this.__url);\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n}\n\nfunction convertAnchorElement(domNode) {\n  let node = null;\n\n  if (domNode instanceof HTMLAnchorElement) {\n    node = $createLinkNode(domNode.href);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createLinkNode(url) {\n  return new LinkNode(url);\n}\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n} // Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\n\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  } // $FlowFixMe[incompatible-extend]\n\n\n  static clone(node) {\n    return new AutoLinkNode(node.__url, node.__key);\n  }\n\n  insertNewAfter(selection) {\n    const element = this.getParentOrThrow().insertNewAfter(selection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url);\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n}\nfunction $createAutoLinkNode(url) {\n  return new AutoLinkNode(url);\n}\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = lexical.createCommand();\n\nexports.$createAutoLinkNode = $createAutoLinkNode;\nexports.$createLinkNode = $createLinkNode;\nexports.$isAutoLinkNode = $isAutoLinkNode;\nexports.$isLinkNode = $isLinkNode;\nexports.AutoLinkNode = AutoLinkNode;\nexports.LinkNode = LinkNode;\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/link/LexicalLink.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/link/LexicalLink.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalLink =  true ? __webpack_require__(/*! ./LexicalLink.dev.js */ \"./node_modules/@lexical/link/LexicalLink.dev.js\") : 0\nmodule.exports = LexicalLink;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/link/LexicalLink.js?");

/***/ }),

/***/ "./node_modules/@lexical/list/LexicalList.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n\n  let parent = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n\nfunction $getAllListItems(node) {\n  let listItemNodes = []; //$FlowFixMe - the result of this will always be an array of ListItemNodes.\n\n  const listChildren = node.getChildren().filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\nfunction findNearestListItemNode(node) {\n  let currentNode = node;\n\n  while (currentNode !== null) {\n    if ($isListItemNode(currentNode)) {\n      return currentNode;\n    }\n\n    currentNode = currentNode.getParent();\n  }\n\n  return null;\n}\nfunction getUniqueListItemNodes(nodeList) {\n  const keys = new Set();\n\n  for (let i = 0; i < nodeList.length; i++) {\n    const node = nodeList[i];\n\n    if ($isListItemNode(node)) {\n      keys.add(node);\n    }\n  }\n\n  return Array.from(keys);\n}\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent(); // This is a special case for when there's nothing selected\n\n      if (nodes.length === 0) {\n        const list = $createListNode(listType);\n\n        if (lexical.$isRootNode(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          list.append(...parent.getChildren());\n          parent.replace(list);\n        }\n\n        return;\n      } else {\n        const handled = new Set();\n\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n\n            while (parent != null) {\n              const parentKey = parent.getKey();\n\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  newListNode.append(...parent.getChildren());\n                  parent.replace(newListNode);\n                  handled.add(parentKey);\n                }\n\n                break;\n              } else {\n                const nextParent = parent.getParent();\n\n                if (lexical.$isRootNode(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n\n  if ($isListNode(previousSibling) && listType === previousSibling.getTag()) {\n    listItem.append(node);\n    previousSibling.append(listItem); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getTag()) {\n      previousSibling.append(...nextSibling.getChildren());\n      nextSibling.remove();\n    }\n\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getTag()) {\n    listItem.append(node);\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    listItem.append(node);\n    return list;\n  }\n}\n\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if (nodes.length === 0 && $isListItemNode(anchorNode)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      listNodes.forEach(listNode => {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        listItems.forEach(listItemNode => {\n          if (listItemNode != null) {\n            const paragraph = lexical.$createParagraphNode();\n            paragraph.append(...listItemNode.getChildren());\n            insertionPoint.insertAfter(paragraph);\n            insertionPoint = paragraph;\n            listItemNode.remove();\n          }\n        });\n        listNode.remove();\n      });\n    }\n  });\n}\nfunction $handleIndent(listItemNodes) {\n  // go through each node and decide where to move it.\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode)) {\n      return;\n    }\n\n    const parent = listItemNode.getParent();\n    const nextSibling = listItemNode.getNextSibling();\n    const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        const nextInnerList = nextSibling.getFirstChild();\n\n        if ($isListNode(nextInnerList)) {\n          const children = nextInnerList.getChildren();\n          innerList.append(...children);\n          nextInnerList.remove();\n        }\n\n        innerList.getChildren().forEach(child => child.markDirty());\n      }\n    } else if (isNestedListNode(nextSibling)) {\n      // if the ListItemNode is next to a nested ListNode, merge them\n      const innerList = nextSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        const firstChild = innerList.getFirstChild();\n\n        if (firstChild !== null) {\n          firstChild.insertBefore(listItemNode);\n        }\n\n        innerList.getChildren().forEach(child => child.markDirty());\n      }\n    } else if (isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        innerList.getChildren().forEach(child => child.markDirty());\n      }\n    } else {\n      // otherwise, we need to create a new nested ListNode\n      if ($isListNode(parent)) {\n        const newListItem = $createListItemNode();\n        const newList = $createListNode(parent.getTag());\n        newListItem.append(newList);\n        newList.append(listItemNode);\n\n        if (previousSibling) {\n          previousSibling.insertAfter(newListItem);\n        } else if (nextSibling) {\n          nextSibling.insertBefore(newListItem);\n        } else {\n          parent.append(newListItem);\n        }\n      }\n    }\n\n    if ($isListNode(parent)) {\n      parent.getChildren().forEach(child => child.markDirty());\n    }\n  });\n}\nfunction $handleOutdent(listItemNodes) {\n  // go through each node and decide where to move it.\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode)) {\n      return;\n    }\n\n    const parentList = listItemNode.getParent();\n    const grandparentListItem = parentList ? parentList.getParent() : undefined;\n    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n      // if it's the first child in it's parent list, insert it into the\n      // great grandparent list before the grandparent\n      const firstChild = parentList ? parentList.getFirstChild() : undefined;\n      const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n      if (listItemNode.is(firstChild)) {\n        grandparentListItem.insertBefore(listItemNode);\n\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        } // if it's the last child in it's parent list, insert it into the\n        // great grandparent list after the grandparent.\n\n      } else if (listItemNode.is(lastChild)) {\n        grandparentListItem.insertAfter(listItemNode);\n\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        }\n      } else {\n        // otherwise, we need to split the siblings into two new nested lists\n        const tag = parentList.getTag();\n        const previousSiblingsListItem = $createListItemNode();\n        const previousSiblingsList = $createListNode(tag);\n        previousSiblingsListItem.append(previousSiblingsList);\n        listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n        const nextSiblingsListItem = $createListItemNode();\n        const nextSiblingsList = $createListNode(tag);\n        nextSiblingsListItem.append(nextSiblingsList);\n        nextSiblingsList.append(...listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n        grandparentListItem.insertBefore(previousSiblingsListItem);\n        grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n        grandparentListItem.replace(listItemNode);\n      }\n\n      parentList.getChildren().forEach(child => child.markDirty());\n      greatGrandparentList.getChildren().forEach(child => child.markDirty());\n    }\n  });\n}\n\nfunction maybeIndentOrOutdent(direction) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const selectedNodes = selection.getNodes();\n  let listItemNodes = [];\n\n  if (selectedNodes.length === 0) {\n    selectedNodes.push(selection.anchor.getNode());\n  }\n\n  if (selectedNodes.length === 1) {\n    // Only 1 node selected. Selection may not contain the ListNodeItem so we traverse the tree to\n    // find whether this is part of a ListItemNode\n    const nearestListItemNode = findNearestListItemNode(selectedNodes[0]);\n\n    if (nearestListItemNode !== null) {\n      listItemNodes = [nearestListItemNode];\n    }\n  } else {\n    listItemNodes = getUniqueListItemNodes(selectedNodes);\n  }\n\n  if (listItemNodes.length > 0) {\n    if (direction === 'indent') {\n      $handleIndent(listItemNodes);\n    } else {\n      $handleOutdent(listItemNodes);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction indentList() {\n  return maybeIndentOrOutdent('indent');\n}\nfunction outdentList() {\n  return maybeIndentOrOutdent('outdent');\n}\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n\n  const grandparent = parent.getParent();\n  let replacementNode;\n\n  if (lexical.$isRootNode(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getTag());\n\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass ListItemNode extends lexical.ElementNode {\n  static getType() {\n    return 'listitem';\n  }\n\n  static clone(node) {\n    return new ListItemNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('li');\n    element.value = getListItemValue(this);\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    //$FlowFixMe - this is always HTMLListItemElement\n    dom.value = getListItemValue(this);\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  } // Mutation\n\n\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace(replaceWithNode) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n\n    const list = this.getParentOrThrow();\n\n    if ($isListNode(list)) {\n      const childrenKeys = list.__children;\n      const childrenLength = childrenKeys.length;\n      const index = childrenKeys.indexOf(this.__key);\n\n      if (index === 0) {\n        list.insertBefore(replaceWithNode);\n      } else if (index === childrenLength - 1) {\n        list.insertAfter(replaceWithNode);\n      } else {\n        // Split the list\n        const newList = $createListNode(list.getTag());\n        const children = list.getChildren();\n\n        for (let i = index + 1; i < childrenLength; i++) {\n          const child = children[i];\n          newList.append(child);\n        }\n\n        list.insertAfter(replaceWithNode);\n        replaceWithNode.insertAfter(newList);\n      }\n\n      this.remove();\n\n      if (childrenLength === 1) {\n        list.remove();\n      }\n    }\n\n    return replaceWithNode;\n  }\n\n  insertAfter(node) {\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(node)) {\n      // mark subsequent list items dirty so we update their value attribute.\n      siblings.forEach(sibling => sibling.markDirty());\n      return super.insertAfter(node);\n    }\n\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    } // Attempt to merge tables if the list is of the same type.\n\n\n    if ($isListNode(node) && node.getTag() === listNode.getTag()) {\n      let child = node;\n      const children = node.getChildren();\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child);\n      }\n\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n\n    listNode.insertAfter(node);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getTag());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode);\n    }\n\n    return node;\n  }\n\n  insertNewAfter() {\n    const newElement = $createListItemNode();\n    this.insertAfter(newElement);\n    return newElement;\n  }\n\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.replace(paragraph); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getIndent() {\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = this.getParentOrThrow().getParentOrThrow();\n    let indentLevel = 0;\n\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent) {\n    let currentIndent = this.getIndent();\n\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent([this]);\n        currentIndent++;\n      } else {\n        $handleOutdent([this]);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  insertBefore(nodeToInsert) {\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(nodeToInsert)) {\n      // mark subsequent list items dirty so we update their value attribute.\n      siblings.forEach(sibling => sibling.markDirty());\n    }\n\n    return super.insertBefore(nodeToInsert);\n  }\n\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n\n}\n\nfunction getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n\n  const siblings = listItem.getPreviousSiblings();\n\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n\n  return value;\n}\n\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n}\n\nfunction convertListItemElement(domNode) {\n  return {\n    node: $createListItemNode()\n  };\n}\n\nfunction $createListItemNode() {\n  return new ListItemNode();\n}\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass ListNode extends lexical.ElementNode {\n  static getType() {\n    return 'list';\n  }\n\n  static clone(node) {\n    return new ListNode(node.__tag, node.__start, node.__key);\n  }\n\n  constructor(tag, start, key) {\n    super(key);\n    this.__tag = tag;\n    this.__start = start;\n  }\n\n  getTag() {\n    return this.__tag;\n  }\n\n  getStart() {\n    return this.__start;\n  } // View\n\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        }\n\n        super.append(listItemNode);\n      }\n    }\n\n    return this;\n  }\n\n}\n\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[node.__tag + 'Depth'] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n}\n\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'ol' || nodeName === 'ul') {\n    node = $createListNode(nodeName);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createListNode(tag, start = 1) {\n  return new ListNode(tag, start);\n}\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand();\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand();\nconst REMOVE_LIST_COMMAND = lexical.createCommand();\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.indentList = indentList;\nexports.insertList = insertList;\nexports.outdentList = outdentList;\nexports.removeList = removeList;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/list/LexicalList.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/list/LexicalList.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalList =  true ? __webpack_require__(/*! ./LexicalList.dev.js */ \"./node_modules/@lexical/list/LexicalList.dev.js\") : 0\nmodule.exports = LexicalList;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/list/LexicalList.js?");

/***/ }),

/***/ "./node_modules/@lexical/markdown/LexicalMarkdown.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.dev.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar code = __webpack_require__(/*! @lexical/code */ \"./node_modules/@lexical/code/LexicalCode.js\");\nvar list = __webpack_require__(/*! @lexical/list */ \"./node_modules/@lexical/list/LexicalList.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\nvar link = __webpack_require__(/*! @lexical/link */ \"./node_modules/@lexical/link/LexicalLink.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"./node_modules/@lexical/rich-text/LexicalRichText.js\");\nvar text = __webpack_require__(/*! @lexical/text */ \"./node_modules/@lexical/text/LexicalText.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n/*\n   How to add a new syntax to capture and transform.\n   1. Create a new enumeration by adding to MarkdownFormatKind.\n   2. Add a new criteria with a regEx pattern. See markdownStrikethrough as an example.\n   3. Add your block criteria (e.g. '# ') to allMarkdownCriteria or \n      your text criteria (e.g. *MyItalic*) to allMarkdownCriteriaForTextNodes.\n   4. Add your Lexical block specific transforming code here: transformTextNodeForText.   \n      Add your Lexical text specific transforming code here: transformTextNodeForText.   \n   */\n// The trigger state helps to capture EditorState information\n// from the prior and current EditorState.\n// This is then used to determined if an auto format has been triggered.\n\n// Eventually we need to support multiple trigger string's including newlines.\nconst SEPARATOR_BETWEEN_TEXT_AND_NON_TEXT_NODES = '\\u0004'; // Select an unused unicode character to separate text and non-text nodes.\n\nconst SEPARATOR_LENGTH = SEPARATOR_BETWEEN_TEXT_AND_NON_TEXT_NODES.length;\nconst spaceTrigger = {\n  triggerKind: 'space_trigger',\n  triggerString: '\\u0020'\n}; // Future todo: add support for ``` + carriage return either inside or not inside code block. Should toggle between.\n// const codeBlockTrigger : AutoFormatTrigger = {\n//     triggerKind: 'codeBlock_trigger',\n//     triggerString: '```', // + new paragraph element or new code block element.\n// };\n\nconst triggers = [spaceTrigger\n/*, codeBlockTrigger*/\n]; // Future Todo: speed up performance by having non-capture group variations of the regex.\n\nconst autoFormatBase = {\n  markdownFormatKind: null,\n  regEx: /(?:)/,\n  regExForAutoFormatting: /(?:)/,\n  requiresParagraphStart: false\n};\nconst paragraphStartBase = { ...autoFormatBase,\n  requiresParagraphStart: true\n};\nconst markdownHeader1 = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphH1',\n  regEx: /^(?:# )/,\n  regExForAutoFormatting: /^(?:# )/\n};\nconst markdownHeader2 = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphH2',\n  regEx: /^(?:## )/,\n  regExForAutoFormatting: /^(?:## )/\n};\nconst markdownHeader3 = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphH3',\n  regEx: /^(?:### )/,\n  regExForAutoFormatting: /^(?:### )/\n};\nconst markdownHeader4 = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphH4',\n  regEx: /^(?:#### )/,\n  regExForAutoFormatting: /^(?:#### )/\n};\nconst markdownHeader5 = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphH5',\n  regEx: /^(?:##### )/,\n  regExForAutoFormatting: /^(?:##### )/\n};\nconst markdownBlockQuote = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphBlockQuote',\n  regEx: /^(?:> )/,\n  regExForAutoFormatting: /^(?:> )/\n};\nconst markdownUnorderedListDash = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphUnorderedList',\n  regEx: /^(\\s{0,10})(?:- )/,\n  regExForAutoFormatting: /^(\\s{0,10})(?:- )/\n};\nconst markdownUnorderedListAsterisk = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphUnorderedList',\n  regEx: /^(\\s{0,10})(?:\\* )/,\n  regExForAutoFormatting: /^(\\s{0,10})(?:\\* )/\n};\nconst markdownCodeBlock = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphCodeBlock',\n  regEx: /^(```)$/,\n  regExForAutoFormatting: /^(```)([a-z]*)( )/\n};\nconst markdownOrderedList = { ...paragraphStartBase,\n  markdownFormatKind: 'paragraphOrderedList',\n  regEx: /^(\\s{0,10})(\\d+)\\.\\s/,\n  regExForAutoFormatting: /^(\\s{0,10})(\\d+)\\.\\s/\n};\nconst markdownHorizontalRule = { ...paragraphStartBase,\n  markdownFormatKind: 'horizontalRule',\n  regEx: /^(?:\\*\\*\\*)$/,\n  regExForAutoFormatting: /^(?:\\*\\*\\* )/\n};\nconst markdownHorizontalRuleUsingDashes = { ...paragraphStartBase,\n  markdownFormatKind: 'horizontalRule',\n  regEx: /^(?:---)$/,\n  regExForAutoFormatting: /^(?:--- )/\n};\nconst markdownInlineCode = { ...autoFormatBase,\n  markdownFormatKind: 'code',\n  regEx: /(`)([^`]*)(`)/,\n  regExForAutoFormatting: /(`)(\\s*\\b)([^`]*)(\\b\\s*)(`)(\\s)$/\n};\nconst markdownBold = { ...autoFormatBase,\n  markdownFormatKind: 'bold',\n  regEx: /(\\*\\*)(\\s*)([^\\*\\*]*)(\\s*)(\\*\\*)()/,\n  regExForAutoFormatting: /(\\*\\*)(\\s*\\b)([^\\*\\*]*)(\\b\\s*)(\\*\\*)(\\s)$/\n};\nconst markdownItalic = { ...autoFormatBase,\n  markdownFormatKind: 'italic',\n  regEx: /(\\*)(\\s*)([^\\*]*)(\\s*)(\\*)()/,\n  regExForAutoFormatting: /(\\*)(\\s*\\b)([^\\*]*)(\\b\\s*)(\\*)(\\s)$/\n};\nconst markdownBold2 = { ...autoFormatBase,\n  markdownFormatKind: 'bold',\n  regEx: /(__)(\\s*)([^__]*)(\\s*)(__)()/,\n  regExForAutoFormatting: /(__)(\\s*)([^__]*)(\\s*)(__)(\\s)$/\n};\nconst markdownItalic2 = { ...autoFormatBase,\n  markdownFormatKind: 'italic',\n  regEx: /(_)()([^_]*)()(_)()/,\n  regExForAutoFormatting: /(_)()([^_]*)()(_)(\\s)$/ // Maintain 7 groups.\n\n}; // Markdown does not support underline, but we can allow folks to use\n// the HTML tags for underline.\n\nconst fakeMarkdownUnderline = { ...autoFormatBase,\n  markdownFormatKind: 'underline',\n  regEx: /(\\<u\\>)(\\s*)([^\\<]*)(\\s*)(\\<\\/u\\>)()/,\n  regExForAutoFormatting: /(\\<u\\>)(\\s*\\b)([^\\<]*)(\\b\\s*)(\\<\\/u\\>)(\\s)$/\n};\nconst markdownStrikethrough = { ...autoFormatBase,\n  markdownFormatKind: 'strikethrough',\n  regEx: /(~~)(\\s*)([^~~]*)(\\s*)(~~)()/,\n  regExForAutoFormatting: /(~~)(\\s*\\b)([^~~]*)(\\b\\s*)(~~)(\\s)$/\n};\nconst markdownStrikethroughItalicBold = { ...autoFormatBase,\n  markdownFormatKind: 'strikethrough_italic_bold',\n  regEx: /(~~_\\*\\*)(\\s*\\b)([^~~_\\*\\*][^\\*\\*_~~]*)(\\b\\s*)(\\*\\*_~~)()/,\n  regExForAutoFormatting: /(~~_\\*\\*)(\\s*\\b)([^~~_\\*\\*][^\\*\\*_~~]*)(\\b\\s*)(\\*\\*_~~)(\\s)$/\n};\nconst markdownItalicbold = { ...autoFormatBase,\n  markdownFormatKind: 'italic_bold',\n  regEx: /(_\\*\\*)(\\s*\\b)([^_\\*\\*][^\\*\\*_]*)(\\b\\s*)(\\*\\*_)/,\n  regExForAutoFormatting: /(_\\*\\*)(\\s*\\b)([^_\\*\\*][^\\*\\*_]*)(\\b\\s*)(\\*\\*_)(\\s)$/\n};\nconst markdownStrikethroughItalic = { ...autoFormatBase,\n  markdownFormatKind: 'strikethrough_italic',\n  regEx: /(~~_)(\\s*)([^~~_][^_~~]*)(\\s*)(_~~)/,\n  regExForAutoFormatting: /(~~_)(\\s*)([^~~_][^_~~]*)(\\s*)(_~~)(\\s)$/\n};\nconst markdownStrikethroughBold = { ...autoFormatBase,\n  markdownFormatKind: 'strikethrough_bold',\n  regEx: /(~~\\*\\*)(\\s*\\b)([^~~\\*\\*][^\\*\\*~~]*)(\\b\\s*)(\\*\\*~~)/,\n  regExForAutoFormatting: /(~~\\*\\*)(\\s*\\b)([^~~\\*\\*][^\\*\\*~~]*)(\\b\\s*)(\\*\\*~~)(\\s)$/\n};\nconst markdownLink = { ...autoFormatBase,\n  markdownFormatKind: 'link',\n  regEx: /(\\[)([^\\]]*)(\\]\\()([^)]*)(\\)*)()/,\n  regExForAutoFormatting: /(\\[)([^\\]]*)(\\]\\()([^)]*)(\\)*)(\\s)$/\n};\nconst allMarkdownCriteriaForTextNodes = [// Place the combination formats ahead of the individual formats.\n// Combos\nmarkdownStrikethroughItalicBold, markdownItalicbold, markdownStrikethroughItalic, markdownStrikethroughBold, // Individuals\nmarkdownInlineCode, markdownBold, markdownItalic, // Must appear after markdownBold\nmarkdownBold2, markdownItalic2, // Must appear after markdownBold2.\nfakeMarkdownUnderline, markdownStrikethrough, markdownLink];\nconst allMarkdownCriteriaForParagraphs = [markdownHeader1, markdownHeader2, markdownHeader3, markdownHeader4, markdownHeader5, markdownBlockQuote, markdownUnorderedListDash, markdownUnorderedListAsterisk, markdownOrderedList, markdownCodeBlock, markdownHorizontalRule, markdownHorizontalRuleUsingDashes];\nconst allMarkdownCriteria = [...allMarkdownCriteriaForParagraphs, ...allMarkdownCriteriaForTextNodes];\nfunction getAllTriggers() {\n  return triggers;\n}\nfunction getAllMarkdownCriteriaForParagraphs() {\n  return allMarkdownCriteriaForParagraphs;\n}\nfunction getAllMarkdownCriteriaForTextNodes() {\n  return allMarkdownCriteriaForTextNodes;\n}\nfunction getAllMarkdownCriteria() {\n  return allMarkdownCriteria;\n}\nfunction getInitialScanningContext(editor, isAutoFormatting, textNodeWithOffset, triggerState) {\n  return {\n    currentElementNode: null,\n    editor,\n    isAutoFormatting,\n    isWithinCodeBlock: false,\n    joinedText: null,\n    markdownCriteria: {\n      markdownFormatKind: 'noTransformation',\n      regEx: /(?:)/,\n      // Empty reg ex.\n      regExForAutoFormatting: /(?:)/,\n      // Empty reg ex.\n      requiresParagraphStart: null\n    },\n    patternMatchResults: {\n      regExCaptureGroups: []\n    },\n    textNodeWithOffset,\n    triggerState\n  };\n}\nfunction resetScanningContext(scanningContext) {\n  scanningContext.joinedText = null;\n  scanningContext.markdownCriteria = {\n    markdownFormatKind: 'noTransformation',\n    regEx: /(?:)/,\n    // Empty reg ex.\n    regExForAutoFormatting: /(?:)/,\n    // Empty reg ex.\n    requiresParagraphStart: null\n  };\n  scanningContext.patternMatchResults = {\n    regExCaptureGroups: []\n  };\n  scanningContext.triggerState = null;\n  scanningContext.textNodeWithOffset = null;\n  return scanningContext;\n}\nfunction getCodeBlockCriteria() {\n  return markdownCodeBlock;\n}\nfunction getPatternMatchResultsForCriteria(markdownCriteria, scanningContext, parentElementNode) {\n  if (markdownCriteria.requiresParagraphStart === true) {\n    return getPatternMatchResultsForParagraphs(markdownCriteria, scanningContext);\n  }\n\n  return getPatternMatchResultsForText(markdownCriteria, scanningContext, parentElementNode);\n}\nfunction getPatternMatchResultsForCodeBlock(scanningContext, text) {\n  const markdownCriteria = getCodeBlockCriteria();\n  return getPatternMatchResultsWithRegEx(text, true, false, scanningContext.isAutoFormatting ? markdownCriteria.regExForAutoFormatting : markdownCriteria.regEx);\n}\n\nfunction getPatternMatchResultsWithRegEx(textToSearch, matchMustAppearAtStartOfString, matchMustAppearAtEndOfString, regEx) {\n  const patternMatchResults = {\n    regExCaptureGroups: []\n  };\n  const regExMatches = textToSearch.match(regEx);\n\n  if (regExMatches !== null && regExMatches.length > 0 && (matchMustAppearAtStartOfString === false || regExMatches.index === 0) && (matchMustAppearAtEndOfString === false || regExMatches.index + regExMatches[0].length === textToSearch.length)) {\n    const captureGroupsCount = regExMatches.length;\n    let runningLength = regExMatches.index;\n\n    for (let captureGroupIndex = 0; captureGroupIndex < captureGroupsCount; captureGroupIndex++) {\n      const textContent = regExMatches[captureGroupIndex];\n      patternMatchResults.regExCaptureGroups.push({\n        offsetInParent: runningLength,\n        text: textContent\n      }); // The 0th capture group is special in that it's text contents is\n      // a join of all subsequent capture groups. So, skip this group\n      // when calculating the runningLength.\n\n      if (captureGroupIndex > 0) {\n        runningLength += textContent.length;\n      }\n    }\n\n    return patternMatchResults;\n  }\n\n  return null;\n}\n\nfunction hasPatternMatchResults(scanningContext) {\n  return scanningContext.patternMatchResults.regExCaptureGroups.length > 0;\n}\nfunction getTextNodeWithOffsetOrThrow(scanningContext) {\n  const textNodeWithOffset = scanningContext.textNodeWithOffset;\n\n  if (textNodeWithOffset == null) {\n    {\n      throw Error(`Expect to have a text node with offset.`);\n    }\n  }\n\n  return textNodeWithOffset;\n}\n\nfunction getPatternMatchResultsForParagraphs(markdownCriteria, scanningContext) {\n  const textNodeWithOffset = getTextNodeWithOffsetOrThrow(scanningContext); // At start of paragraph.\n\n  if (textNodeWithOffset.node.getPreviousSibling() === null) {\n    const textToSearch = textNodeWithOffset.node.getTextContent();\n    return getPatternMatchResultsWithRegEx(textToSearch, true, false, scanningContext.isAutoFormatting ? markdownCriteria.regExForAutoFormatting : markdownCriteria.regEx);\n  }\n\n  return null;\n}\n\nfunction getPatternMatchResultsForText(markdownCriteria, scanningContext, parentElementNode) {\n  if (scanningContext.joinedText == null) {\n    if (lexical.$isElementNode(parentElementNode)) {\n      if (scanningContext.joinedText == null) {\n        // Lazy calculate the text to search.\n        scanningContext.joinedText = text.$joinTextNodesInElementNode(parentElementNode, SEPARATOR_BETWEEN_TEXT_AND_NON_TEXT_NODES, getTextNodeWithOffsetOrThrow(scanningContext));\n      }\n    } else {\n      {\n        throw Error(`Expected node ${parentElementNode.__key} to to be a ElementNode.`);\n      }\n    }\n  }\n\n  const matchMustAppearAtEndOfString = markdownCriteria.regExForAutoFormatting === true;\n  return getPatternMatchResultsWithRegEx(scanningContext.joinedText, false, matchMustAppearAtEndOfString, scanningContext.isAutoFormatting ? markdownCriteria.regExForAutoFormatting : markdownCriteria.regEx);\n}\n\nfunction getNewNodeForCriteria(scanningContext, element, createHorizontalRuleNode) {\n  let newNode = null;\n  const shouldDelete = false;\n  const children = element.getChildren();\n  const markdownCriteria = scanningContext.markdownCriteria;\n  const patternMatchResults = scanningContext.patternMatchResults;\n\n  if (markdownCriteria.markdownFormatKind != null) {\n    switch (markdownCriteria.markdownFormatKind) {\n      case 'paragraphH1':\n        {\n          newNode = richText.$createHeadingNode('h1');\n          newNode.append(...children);\n          return {\n            newNode,\n            shouldDelete\n          };\n        }\n\n      case 'paragraphH2':\n        {\n          newNode = richText.$createHeadingNode('h2');\n          newNode.append(...children);\n          return {\n            newNode,\n            shouldDelete\n          };\n        }\n\n      case 'paragraphH3':\n        {\n          newNode = richText.$createHeadingNode('h3');\n          newNode.append(...children);\n          return {\n            newNode,\n            shouldDelete\n          };\n        }\n\n      case 'paragraphH4':\n        {\n          newNode = richText.$createHeadingNode('h4');\n          newNode.append(...children);\n          return {\n            newNode,\n            shouldDelete\n          };\n        }\n\n      case 'paragraphH5':\n        {\n          newNode = richText.$createHeadingNode('h5');\n          newNode.append(...children);\n          return {\n            newNode,\n            shouldDelete\n          };\n        }\n\n      case 'paragraphBlockQuote':\n        {\n          newNode = richText.$createQuoteNode();\n          newNode.append(...children);\n          return {\n            newNode,\n            shouldDelete\n          };\n        }\n\n      case 'paragraphUnorderedList':\n        {\n          createListOrMergeWithPrevious(element, children, patternMatchResults, 'ul');\n          return {\n            newNode: null,\n            shouldDelete: false\n          };\n        }\n\n      case 'paragraphOrderedList':\n        {\n          const startAsString = patternMatchResults.regExCaptureGroups.length > 1 ? patternMatchResults.regExCaptureGroups[patternMatchResults.regExCaptureGroups.length - 1].text : '1'; // For conversion, don't use start number.\n          // For short-cuts aka autoFormatting, use start number.\n          // Later, this should be surface dependent and externalized.\n\n          const start = scanningContext.isAutoFormatting ? parseInt(startAsString, 10) : undefined;\n          createListOrMergeWithPrevious(element, children, patternMatchResults, 'ol', start);\n          return {\n            newNode: null,\n            shouldDelete: false\n          };\n        }\n\n      case 'paragraphCodeBlock':\n        {\n          // Toggle code and paragraph nodes.\n          if (scanningContext.isAutoFormatting === false) {\n            const shouldToggle = hasPatternMatchResults(scanningContext);\n\n            if (shouldToggle) {\n              scanningContext.isWithinCodeBlock = scanningContext.isWithinCodeBlock !== true; // When toggling, always clear the code block element node.\n\n              scanningContext.currentElementNode = null;\n              return {\n                newNode: null,\n                shouldDelete: true\n              };\n            }\n\n            if (scanningContext.isWithinCodeBlock) {\n              // Create the code block and return it to the caller.\n              if (scanningContext.currentElementNode == null) {\n                const newCodeBlockNode = code.$createCodeNode();\n                newCodeBlockNode.append(...children);\n                scanningContext.currentElementNode = newCodeBlockNode;\n                return {\n                  newNode: newCodeBlockNode,\n                  shouldDelete: false\n                };\n              } // Build up the code block with a line break and the children.\n\n\n              if (scanningContext.currentElementNode != null) {\n                const codeBlockNode = scanningContext.currentElementNode;\n                const lineBreakNode = lexical.$createLineBreakNode();\n                codeBlockNode.append(lineBreakNode);\n\n                if (children.length) {\n                  codeBlockNode.append(lineBreakNode);\n                }\n\n                codeBlockNode.append(...children);\n              }\n            }\n\n            return {\n              newNode: null,\n              shouldDelete: true\n            };\n          }\n\n          if (scanningContext.triggerState != null && scanningContext.triggerState.isCodeBlock) {\n            newNode = lexical.$createParagraphNode();\n          } else {\n            newNode = code.$createCodeNode();\n            const codingLanguage = patternMatchResults.regExCaptureGroups.length >= 3 ? patternMatchResults.regExCaptureGroups[2].text : null;\n\n            if (codingLanguage != null && codingLanguage.length > 0) {\n              newNode.setLanguage(codingLanguage);\n            }\n          }\n\n          newNode.append(...children);\n          return {\n            newNode,\n            shouldDelete\n          };\n        }\n\n      case 'horizontalRule':\n        {\n          if (createHorizontalRuleNode != null) {\n            // return null for newNode. Insert the HR here.\n            const horizontalRuleNode = createHorizontalRuleNode();\n            element.insertBefore(horizontalRuleNode);\n          }\n\n          break;\n        }\n    }\n  }\n\n  return {\n    newNode,\n    shouldDelete\n  };\n}\n\nfunction createListOrMergeWithPrevious(element, children, patternMatchResults, tag, start) {\n  const listItem = list.$createListItemNode();\n  const indentMatch = patternMatchResults.regExCaptureGroups[0].text.match(/^\\s*/);\n  const indent = indentMatch ? Math.floor(indentMatch[0].length / 4) : 0;\n  listItem.append(...children); // Checking if previous element is a list, and if so append\n  // new list item inside instead of creating new list\n\n  const prevElement = element.getPreviousSibling();\n\n  if (list.$isListNode(prevElement) && prevElement.getTag() === tag) {\n    prevElement.append(listItem);\n    element.remove();\n  } else {\n    const list$1 = list.$createListNode(tag, start);\n    list$1.append(listItem);\n    element.replace(list$1);\n  }\n\n  if (indent) {\n    listItem.setIndent(indent);\n  }\n}\n\nfunction transformTextNodeForMarkdownCriteria(scanningContext, elementNode, createHorizontalRuleNode) {\n  if (scanningContext.markdownCriteria.requiresParagraphStart === true) {\n    transformTextNodeForElementNode(elementNode, scanningContext, createHorizontalRuleNode);\n  } else {\n    transformTextNodeForText(scanningContext, elementNode);\n  }\n}\n\nfunction transformTextNodeForElementNode(elementNode, scanningContext, createHorizontalRuleNode) {\n  if (scanningContext.textNodeWithOffset != null) {\n    const textNodeWithOffset = getTextNodeWithOffsetOrThrow(scanningContext);\n\n    if (hasPatternMatchResults(scanningContext)) {\n      const text = scanningContext.patternMatchResults.regExCaptureGroups[0].text; // Remove the text which we matched.\n\n      const textNode = textNodeWithOffset.node.spliceText(0, text.length, '', true);\n\n      if (textNode.getTextContent() === '') {\n        textNode.selectPrevious();\n        textNode.remove();\n      }\n    }\n  } // Transform the current element kind to the new element kind.\n\n\n  const {\n    newNode,\n    shouldDelete\n  } = getNewNodeForCriteria(scanningContext, elementNode, createHorizontalRuleNode);\n\n  if (shouldDelete) {\n    elementNode.remove();\n  } else if (newNode !== null) {\n    elementNode.replace(newNode);\n  }\n}\n\nfunction transformTextNodeForText(scanningContext, parentElementNode) {\n  const markdownCriteria = scanningContext.markdownCriteria;\n\n  if (markdownCriteria.markdownFormatKind != null) {\n    const formatting = getTextFormatType(markdownCriteria.markdownFormatKind);\n\n    if (formatting != null) {\n      transformTextNodeWithFormatting(formatting, scanningContext, parentElementNode);\n      return;\n    }\n\n    if (markdownCriteria.markdownFormatKind === 'link') {\n      transformTextNodeWithLink(scanningContext, parentElementNode);\n    }\n  }\n}\n\nfunction transformTextNodeWithFormatting(formatting, scanningContext, parentElementNode) {\n  const patternMatchResults = scanningContext.patternMatchResults;\n  const groupCount = patternMatchResults.regExCaptureGroups.length;\n\n  if (groupCount !== 7) {\n    // For BIUS and similar formats which have a pattern + text + pattern:\n    // given '*italic* ' below are the capture groups by index:\n    // 0. '*italic* '\n    // 1. '*'\n    // 2. whitespace  // typically this is \"\".\n    // 3. 'italic'\n    // 4. whitespace  // typicallly this is \"\".\n    // 5. '*'\n    // 6. ' '\n    return;\n  } // Remove unwanted text in reg ex pattern.\n  // Remove group 5.\n\n\n  removeTextByCaptureGroups(5, 5, scanningContext, parentElementNode); // Remove group 1.\n\n  removeTextByCaptureGroups(1, 1, scanningContext, parentElementNode); // Apply the formatting.\n\n  formatTextInCaptureGroupIndex(formatting, 3, scanningContext, parentElementNode); // Place caret at end of final capture group.\n\n  selectAfterFinalCaptureGroup(scanningContext, parentElementNode);\n}\n\nfunction transformTextNodeWithLink(scanningContext, parentElementNode) {\n  const patternMatchResults = scanningContext.patternMatchResults;\n  const regExCaptureGroups = patternMatchResults.regExCaptureGroups;\n  const groupCount = regExCaptureGroups.length;\n\n  if (groupCount !== 7) {\n    // For links and similar formats which have: pattern + text + pattern + pattern2 text2 + pattern2:\n    // Given '[title](url) ', below are the capture groups by index:\n    // 0. '[title](url) '\n    // 1. '['\n    // 2. 'title'\n    // 3. ']('\n    // 4. 'url'\n    // 5. ')'\n    // 6. ' '\n    return;\n  }\n\n  const title = regExCaptureGroups[2].text;\n  const url = regExCaptureGroups[4].text;\n\n  if (title.length === 0 || url.length === 0) {\n    return;\n  } // Remove the initial pattern through to the final pattern.\n\n\n  removeTextByCaptureGroups(1, 5, scanningContext, parentElementNode);\n  insertTextPriorToCaptureGroup(1, // Insert at the beginning of the meaningful capture groups, namely index 1. Index 0 refers to the whole matched string.\n  title, scanningContext, parentElementNode);\n  const newSelectionForLink = createSelectionWithCaptureGroups(1, 1, false, true, scanningContext, parentElementNode);\n\n  if (newSelectionForLink == null) {\n    return;\n  }\n\n  lexical.$setSelection(newSelectionForLink);\n  scanningContext.editor.dispatchCommand(link.TOGGLE_LINK_COMMAND, url); // Place caret at end of final capture group.\n\n  selectAfterFinalCaptureGroup(scanningContext, parentElementNode);\n} // Below are lower level helper functions.\n\n\nfunction getParentElementNodeOrThrow(scanningContext) {\n  return getTextNodeWithOffsetOrThrow(scanningContext).node.getParentOrThrow();\n}\n\nfunction getJoinedTextLength(patternMatchResults) {\n  const groupCount = patternMatchResults.regExCaptureGroups.length;\n\n  if (groupCount < 2) {\n    // Ignore capture group 0, as regEx defaults the 0th one to the entire matched string.\n    return 0;\n  }\n\n  const lastGroupIndex = groupCount - 1;\n  return patternMatchResults.regExCaptureGroups[lastGroupIndex].offsetInParent + patternMatchResults.regExCaptureGroups[lastGroupIndex].text.length;\n}\n\nfunction getTextFormatType(markdownFormatKind) {\n  switch (markdownFormatKind) {\n    case 'italic':\n    case 'bold':\n    case 'underline':\n    case 'strikethrough':\n    case 'code':\n      return [markdownFormatKind];\n\n    case 'strikethrough_italic_bold':\n      {\n        return ['strikethrough', 'italic', 'bold'];\n      }\n\n    case 'italic_bold':\n      {\n        return ['italic', 'bold'];\n      }\n\n    case 'strikethrough_italic':\n      {\n        return ['strikethrough', 'italic'];\n      }\n\n    case 'strikethrough_bold':\n      {\n        return ['strikethrough', 'bold'];\n      }\n  }\n\n  return null;\n}\n\nfunction createSelectionWithCaptureGroups(anchorCaptureGroupIndex, focusCaptureGroupIndex, startAtEndOfAnchor, finishAtEndOfFocus, scanningContext, parentElementNode) {\n  const patternMatchResults = scanningContext.patternMatchResults;\n  const regExCaptureGroups = patternMatchResults.regExCaptureGroups;\n  const regExCaptureGroupsCount = regExCaptureGroups.length;\n\n  if (anchorCaptureGroupIndex >= regExCaptureGroupsCount || focusCaptureGroupIndex >= regExCaptureGroupsCount) {\n    return null;\n  }\n\n  const joinedTextLength = getJoinedTextLength(patternMatchResults);\n  const anchorCaptureGroupDetail = regExCaptureGroups[anchorCaptureGroupIndex];\n  const focusCaptureGroupDetail = regExCaptureGroups[focusCaptureGroupIndex];\n  const anchorLocation = startAtEndOfAnchor ? anchorCaptureGroupDetail.offsetInParent + anchorCaptureGroupDetail.text.length : anchorCaptureGroupDetail.offsetInParent;\n  const focusLocation = finishAtEndOfFocus ? focusCaptureGroupDetail.offsetInParent + focusCaptureGroupDetail.text.length : focusCaptureGroupDetail.offsetInParent;\n  const anchorTextNodeWithOffset = text.$findNodeWithOffsetFromJoinedText(anchorLocation, joinedTextLength, SEPARATOR_LENGTH, parentElementNode);\n  const focusTextNodeWithOffset = text.$findNodeWithOffsetFromJoinedText(focusLocation, joinedTextLength, SEPARATOR_LENGTH, parentElementNode);\n\n  if (anchorTextNodeWithOffset == null && focusTextNodeWithOffset == null && parentElementNode.getChildren().length === 0) {\n    const emptyElementSelection = lexical.$createRangeSelection();\n    emptyElementSelection.anchor.set(parentElementNode.getKey(), 0, 'element');\n    emptyElementSelection.focus.set(parentElementNode.getKey(), 0, 'element');\n    return emptyElementSelection;\n  }\n\n  if (anchorTextNodeWithOffset == null || focusTextNodeWithOffset == null) {\n    return null;\n  }\n\n  const selection = lexical.$createRangeSelection();\n  selection.anchor.set(anchorTextNodeWithOffset.node.getKey(), anchorTextNodeWithOffset.offset, 'text');\n  selection.focus.set(focusTextNodeWithOffset.node.getKey(), focusTextNodeWithOffset.offset, 'text');\n  return selection;\n}\n\nfunction removeTextByCaptureGroups(anchorCaptureGroupIndex, focusCaptureGroupIndex, scanningContext, parentElementNode) {\n  const patternMatchResults = scanningContext.patternMatchResults;\n  const regExCaptureGroups = patternMatchResults.regExCaptureGroups;\n  const newSelection = createSelectionWithCaptureGroups(anchorCaptureGroupIndex, focusCaptureGroupIndex, false, true, scanningContext, parentElementNode);\n\n  if (newSelection != null) {\n    lexical.$setSelection(newSelection);\n    const currentSelection = lexical.$getSelection();\n\n    if (currentSelection != null && lexical.$isRangeSelection(currentSelection) && currentSelection.isCollapsed() === false) {\n      currentSelection.removeText(); // Shift all group offsets and clear out group text.\n\n      let runningLength = 0;\n      const groupCount = regExCaptureGroups.length;\n\n      for (let i = anchorCaptureGroupIndex; i < groupCount; i++) {\n        const captureGroupDetail = regExCaptureGroups[i];\n\n        if (i > anchorCaptureGroupIndex) {\n          captureGroupDetail.offsetInParent -= runningLength;\n        }\n\n        if (i <= focusCaptureGroupIndex) {\n          runningLength += captureGroupDetail.text.length;\n          captureGroupDetail.text = '';\n        }\n      }\n    }\n  }\n}\n\nfunction insertTextPriorToCaptureGroup(captureGroupIndex, text, scanningContext, parentElementNode) {\n  const patternMatchResults = scanningContext.patternMatchResults;\n  const regExCaptureGroups = patternMatchResults.regExCaptureGroups;\n  const regExCaptureGroupsCount = regExCaptureGroups.length;\n\n  if (captureGroupIndex >= regExCaptureGroupsCount) {\n    return;\n  }\n\n  const captureGroupDetail = regExCaptureGroups[captureGroupIndex];\n  const newCaptureGroupDetail = {\n    offsetInParent: captureGroupDetail.offsetInParent,\n    text\n  };\n  const newSelection = createSelectionWithCaptureGroups(captureGroupIndex, captureGroupIndex, false, false, scanningContext, parentElementNode);\n\n  if (newSelection != null) {\n    lexical.$setSelection(newSelection);\n    const currentSelection = lexical.$getSelection();\n\n    if (currentSelection != null && lexical.$isRangeSelection(currentSelection) && currentSelection.isCollapsed()) {\n      currentSelection.insertText(newCaptureGroupDetail.text); // Update the capture groups.\n\n      regExCaptureGroups.splice(captureGroupIndex, 0, newCaptureGroupDetail);\n      const textLength = newCaptureGroupDetail.text.length;\n      const newGroupCount = regExCaptureGroups.length;\n\n      for (let i = captureGroupIndex + 1; i < newGroupCount; i++) {\n        const currentCaptureGroupDetail = regExCaptureGroups[i];\n        currentCaptureGroupDetail.offsetInParent += textLength;\n      }\n    }\n  }\n}\n\nfunction formatTextInCaptureGroupIndex(formatTypes, captureGroupIndex, scanningContext, parentElementNode) {\n  const patternMatchResults = scanningContext.patternMatchResults;\n  const regExCaptureGroups = patternMatchResults.regExCaptureGroups;\n  const regExCaptureGroupsCount = regExCaptureGroups.length;\n\n  if (!(captureGroupIndex < regExCaptureGroupsCount)) {\n    throw Error(`The capture group count in the RegEx does match the actual capture group count.`);\n  }\n\n  const captureGroupDetail = regExCaptureGroups[captureGroupIndex];\n\n  if (captureGroupDetail.text.length === 0) {\n    return;\n  }\n\n  const newSelection = createSelectionWithCaptureGroups(captureGroupIndex, captureGroupIndex, false, true, scanningContext, parentElementNode);\n\n  if (newSelection != null) {\n    lexical.$setSelection(newSelection);\n    const currentSelection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(currentSelection)) {\n      for (let i = 0; i < formatTypes.length; i++) {\n        currentSelection.formatText(formatTypes[i]);\n      }\n    }\n  }\n} // Place caret at end of final capture group.\n\n\nfunction selectAfterFinalCaptureGroup(scanningContext, parentElementNode) {\n  const patternMatchResults = scanningContext.patternMatchResults;\n  const groupCount = patternMatchResults.regExCaptureGroups.length;\n\n  if (groupCount < 2) {\n    // Ignore capture group 0, as regEx defaults the 0th one to the entire matched string.\n    return;\n  }\n\n  const lastGroupIndex = groupCount - 1;\n  const newSelection = createSelectionWithCaptureGroups(lastGroupIndex, lastGroupIndex, true, true, scanningContext, parentElementNode);\n\n  if (newSelection != null) {\n    lexical.$setSelection(newSelection);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction getTextNodeForAutoFormatting(selection) {\n  if (!lexical.$isRangeSelection(selection)) {\n    return null;\n  }\n\n  const node = selection.anchor.getNode();\n\n  if (!lexical.$isTextNode(node)) {\n    return null;\n  }\n\n  return {\n    node,\n    offset: selection.anchor.offset\n  };\n}\n\nfunction updateAutoFormatting(editor, scanningContext, createHorizontalRuleNode) {\n  editor.update(() => {\n    const elementNode = getTextNodeWithOffsetOrThrow(scanningContext).node.getParentOrThrow();\n    transformTextNodeForMarkdownCriteria(scanningContext, elementNode, createHorizontalRuleNode);\n  }, {\n    tag: 'history-push'\n  });\n}\n\nfunction getCriteriaWithPatternMatchResults(markdownCriteriaArray, scanningContext) {\n  const currentTriggerState = scanningContext.triggerState;\n  const count = markdownCriteriaArray.length;\n\n  for (let i = 0; i < count; i++) {\n    const markdownCriteria = markdownCriteriaArray[i]; // Skip code block nodes, unless the autoFormatKind calls for toggling the code block.\n\n    if (currentTriggerState != null && currentTriggerState.isCodeBlock === false || markdownCriteria.markdownFormatKind === 'paragraphCodeBlock') {\n      const patternMatchResults = getPatternMatchResultsForCriteria(markdownCriteria, scanningContext, getParentElementNodeOrThrow(scanningContext));\n\n      if (patternMatchResults != null) {\n        return {\n          markdownCriteria,\n          patternMatchResults\n        };\n      }\n    }\n  }\n\n  return {\n    markdownCriteria: null,\n    patternMatchResults: null\n  };\n}\n\nfunction findScanningContextWithValidMatch(editor, currentTriggerState) {\n  let scanningContext = null;\n  editor.getEditorState().read(() => {\n    const textNodeWithOffset = getTextNodeForAutoFormatting(lexical.$getSelection());\n\n    if (textNodeWithOffset === null) {\n      return;\n    } // Please see the declaration of ScanningContext for a detailed explanation.\n\n\n    const initialScanningContext = getInitialScanningContext(editor, true, textNodeWithOffset, currentTriggerState);\n    const criteriaWithPatternMatchResults = getCriteriaWithPatternMatchResults( // Do not apply paragraph node changes like blockQuote or H1 to listNodes. Also, do not attempt to transform a list into a list using * or -.\n    currentTriggerState.isParentAListItemNode === false ? getAllMarkdownCriteria() : getAllMarkdownCriteriaForTextNodes(), initialScanningContext);\n\n    if (criteriaWithPatternMatchResults.markdownCriteria === null || criteriaWithPatternMatchResults.patternMatchResults === null) {\n      return;\n    }\n\n    scanningContext = initialScanningContext; // Lazy fill-in the particular format criteria and any matching result information.\n\n    scanningContext.markdownCriteria = criteriaWithPatternMatchResults.markdownCriteria;\n    scanningContext.patternMatchResults = criteriaWithPatternMatchResults.patternMatchResults;\n  });\n  return scanningContext;\n}\n\nfunction getTriggerState(editorState) {\n  let criteria = null;\n  editorState.read(() => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n\n    const node = selection.anchor.getNode();\n    const parentNode = node.getParent();\n    const isParentAListItemNode = list.$isListItemNode(parentNode);\n    const hasParentNode = parentNode !== null;\n    criteria = {\n      anchorOffset: selection.anchor.offset,\n      hasParentNode,\n      isCodeBlock: code.$isCodeNode(node),\n      isParentAListItemNode,\n      isSelectionCollapsed: true,\n      isSimpleText: lexical.$isTextNode(node) && node.isSimpleText(),\n      nodeKey: node.getKey(),\n      textContent: node.getTextContent()\n    };\n  });\n  return criteria;\n}\nfunction findScanningContext(editor, currentTriggerState, priorTriggerState) {\n  if (currentTriggerState == null || priorTriggerState == null) {\n    return null;\n  }\n\n  const triggerArray = getAllTriggers();\n  const triggerCount = triggers.length;\n\n  for (let ti = 0; ti < triggerCount; ti++) {\n    const triggerString = triggerArray[ti].triggerString; // The below checks needs to execute relativey quickly, so perform the light-weight ones first.\n    // The substr check is a quick way to avoid autoformat parsing in that it looks for the autoformat\n    // trigger which is the trigger string (\" \").\n\n    const triggerStringLength = triggerString.length;\n    const currentTextContentLength = currentTriggerState.textContent.length;\n    const triggerOffset = currentTriggerState.anchorOffset - triggerStringLength; // Todo: these checks help w/ performance, yet we can do more.\n    // We might consider looking for ** + space or __ + space and so on to boost performance\n    // even further. Make sure the patter is driven from the trigger state type.\n\n    if ((currentTriggerState.hasParentNode === true && currentTriggerState.isSimpleText && currentTriggerState.isSelectionCollapsed && currentTriggerState.anchorOffset !== priorTriggerState.anchorOffset && triggerOffset >= 0 && triggerOffset + triggerStringLength <= currentTextContentLength && currentTriggerState.textContent.substr(triggerOffset, triggerStringLength) === triggerString && // Some code differentiation needed if trigger kind is not a simple space character.\n    currentTriggerState.textContent !== priorTriggerState.textContent) === false) {\n      return null;\n    }\n  }\n\n  return findScanningContextWithValidMatch(editor, currentTriggerState);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction convertStringToLexical(text, editor) {\n  if (!text.length) {\n    return null;\n  }\n\n  const nodes = [];\n  const splitLines = text.split('\\n');\n  const splitLinesCount = splitLines.length;\n\n  for (let i = 0; i < splitLinesCount; i++) {\n    if (splitLines[i].length > 0) {\n      nodes.push(lexical.$createParagraphNode().append(lexical.$createTextNode(splitLines[i])));\n    } else {\n      nodes.push(lexical.$createParagraphNode());\n    }\n  }\n\n  if (nodes.length) {\n    const root = lexical.$getRoot();\n    root.clear();\n    root.append(...nodes);\n    return root;\n  }\n\n  return null;\n}\nfunction convertMarkdownForElementNodes(editor, createHorizontalRuleNode) {\n  // Please see the declaration of ScanningContext for a detailed explanation.\n  const scanningContext = getInitialScanningContext(editor, false, null, null);\n  const root = lexical.$getRoot();\n  let done = false;\n  let startIndex = 0; // Handle the paragraph level markdown.\n\n  while (!done) {\n    done = true;\n    const elementNodes = root.getChildren();\n    const countOfElementNodes = elementNodes.length;\n\n    for (let i = startIndex; i < countOfElementNodes; i++) {\n      const elementNode = elementNodes[i];\n\n      if (lexical.$isElementNode(elementNode)) {\n        convertParagraphLevelMarkdown(scanningContext, elementNode, createHorizontalRuleNode);\n      } // Reset the scanning information that relates to the particular element node.\n\n\n      resetScanningContext(scanningContext);\n\n      if (root.getChildren().length !== countOfElementNodes) {\n        // The conversion added or removed an from root's children.\n        startIndex = i;\n        done = false;\n        break;\n      }\n    }\n  } // while\n\n\n  done = false;\n  startIndex = 0; // Handle the text level markdown.\n\n  while (!done) {\n    done = true;\n    const elementNodes = root.getChildren();\n    const countOfElementNodes = elementNodes.length;\n\n    for (let i = startIndex; i < countOfElementNodes; i++) {\n      const elementNode = elementNodes[i];\n\n      if (lexical.$isElementNode(elementNode)) {\n        convertTextLevelMarkdown(scanningContext, elementNode, createHorizontalRuleNode);\n      } // Reset the scanning information that relates to the particular element node.\n\n\n      resetScanningContext(scanningContext);\n    }\n  } // while\n\n}\n\nfunction convertParagraphLevelMarkdown(scanningContext, elementNode, createHorizontalRuleNode) {\n  const textContent = elementNode.getTextContent(); // Handle paragraph nodes below.\n\n  if (lexical.$isParagraphNode(elementNode)) {\n    const paragraphNode = elementNode;\n    const firstChild = paragraphNode.getFirstChild();\n    const firstChildIsTextNode = lexical.$isTextNode(firstChild); // Handle conversion to code block.\n\n    if (scanningContext.isWithinCodeBlock === true) {\n      if (firstChild != null && firstChildIsTextNode) {\n        // Test if we encounter ending code block.\n        scanningContext.textNodeWithOffset = {\n          node: firstChild,\n          offset: 0\n        };\n        const patternMatchResults = getPatternMatchResultsForCodeBlock(scanningContext, textContent);\n\n        if (patternMatchResults != null) {\n          // Toggle transform to or from code block.\n          scanningContext.patternMatchResults = patternMatchResults;\n        }\n      }\n\n      scanningContext.markdownCriteria = getCodeBlockCriteria(); // Perform text transformation here.\n\n      transformTextNodeForMarkdownCriteria(scanningContext, elementNode, createHorizontalRuleNode);\n      return;\n    }\n\n    if (elementNode.getChildren().length) {\n      const allCriteria = getAllMarkdownCriteriaForParagraphs();\n      const count = allCriteria.length;\n      scanningContext.joinedText = paragraphNode.getTextContent();\n\n      if (!(firstChild != null && firstChildIsTextNode)) {\n        throw Error(`Expect paragraph containing only text nodes.`);\n      }\n\n      scanningContext.textNodeWithOffset = {\n        node: firstChild,\n        offset: 0\n      };\n\n      for (let i = 0; i < count; i++) {\n        const criteria = allCriteria[i];\n\n        if (criteria.requiresParagraphStart === false) {\n          return;\n        }\n\n        const patternMatchResults = getPatternMatchResultsForCriteria(criteria, scanningContext, getParentElementNodeOrThrow(scanningContext));\n\n        if (patternMatchResults != null) {\n          scanningContext.markdownCriteria = criteria;\n          scanningContext.patternMatchResults = patternMatchResults; // Perform text transformation here.\n\n          transformTextNodeForMarkdownCriteria(scanningContext, elementNode, createHorizontalRuleNode);\n          return;\n        }\n      }\n    }\n  }\n}\n\nfunction convertTextLevelMarkdown(scanningContext, elementNode, createHorizontalRuleNode) {\n  const firstChild = elementNode.getFirstChild();\n\n  if (lexical.$isTextNode(firstChild)) {\n    // This function will convert all text nodes within the elementNode.\n    convertMarkdownForTextCriteria(scanningContext, elementNode, createHorizontalRuleNode);\n    return;\n  } // Handle the case where the elementNode has child elementNodes like lists.\n  // Since we started at a text import, we don't need to worry about anything but textNodes.\n\n\n  const children = elementNode.getChildren();\n  const countOfChildren = children.length;\n\n  for (let i = 0; i < countOfChildren; i++) {\n    const node = children[i];\n\n    if (lexical.$isElementNode(node)) {\n      // Recurse down until we find a text node.\n      convertTextLevelMarkdown(scanningContext, node, createHorizontalRuleNode);\n    }\n  }\n}\n\nfunction convertMarkdownForTextCriteria(scanningContext, elementNode, createHorizontalRuleNode) {\n  resetScanningContext(scanningContext); // Cycle through all the criteria and convert all text patterns in the parent element.\n\n  const allCriteria = getAllMarkdownCriteriaForTextNodes();\n  const count = allCriteria.length;\n  let textContent = elementNode.getTextContent();\n  let done = textContent.length === 0;\n  let startIndex = 0;\n\n  while (!done) {\n    done = true;\n\n    for (let i = startIndex; i < count; i++) {\n      const criteria = allCriteria[i];\n\n      if (scanningContext.textNodeWithOffset == null) {\n        // Need to search through the very last text node in the element.\n        const lastTextNode = getLastTextNodeInElementNode(elementNode);\n\n        if (lastTextNode == null) {\n          // If we have no more text nodes, then there's nothing to search and transform.\n          return;\n        }\n\n        scanningContext.textNodeWithOffset = {\n          node: lastTextNode,\n          offset: lastTextNode.getTextContent().length\n        };\n      }\n\n      const patternMatchResults = getPatternMatchResultsForCriteria(criteria, scanningContext, elementNode);\n\n      if (patternMatchResults != null) {\n        scanningContext.markdownCriteria = criteria;\n        scanningContext.patternMatchResults = patternMatchResults; // Perform text transformation here.\n\n        transformTextNodeForMarkdownCriteria(scanningContext, elementNode, createHorizontalRuleNode);\n        resetScanningContext(scanningContext);\n        const currentTextContent = elementNode.getTextContent();\n\n        if (currentTextContent.length === 0) {\n          // Nothing left to convert.\n          return;\n        }\n\n        if (currentTextContent === textContent) {\n          // Nothing was changed by this transformation, so move on to the next crieteria.\n          continue;\n        } // The text was changed. Perhaps there is another hit for the same criteria.\n\n\n        textContent = currentTextContent;\n        startIndex = i;\n        done = false;\n        break;\n      }\n    }\n  }\n}\n\nfunction getLastTextNodeInElementNode(elementNode) {\n  const children = elementNode.getChildren();\n  const countOfChildren = children.length;\n\n  for (let i = countOfChildren - 1; i >= 0; i--) {\n    if (lexical.$isTextNode(children[i])) {\n      return children[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction registerMarkdownShortcuts(editor, createHorizontalRuleNode) {\n  // The priorTriggerState is compared against the currentTriggerState to determine\n  // if the user has performed some typing event that warrants an auto format.\n  // For example, typing \"#\" and then \" \", shoud trigger an format.\n  // However, given \"#A B\", where the user delets \"A\" should not.\n  let priorTriggerState = null;\n  return editor.registerUpdateListener(({\n    tags\n  }) => {\n    // Examine historic so that we are not running autoformatting within markdown.\n    if (tags.has('historic') === false) {\n      const currentTriggerState = getTriggerState(editor.getEditorState());\n      const scanningContext = currentTriggerState == null ? null : findScanningContext(editor, currentTriggerState, priorTriggerState);\n\n      if (scanningContext != null) {\n        updateAutoFormatting(editor, scanningContext, createHorizontalRuleNode);\n      }\n\n      priorTriggerState = currentTriggerState;\n    } else {\n      priorTriggerState = null;\n    }\n  });\n}\nfunction $convertFromMarkdownString(markdownString, editor, createHorizontalRuleNode) {\n  if (convertStringToLexical(markdownString) != null) {\n    convertMarkdownForElementNodes(editor, createHorizontalRuleNode);\n  }\n}\n\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/markdown/LexicalMarkdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMarkdown =  true ? __webpack_require__(/*! ./LexicalMarkdown.dev.js */ \"./node_modules/@lexical/markdown/LexicalMarkdown.dev.js\") : 0\nmodule.exports = LexicalMarkdown;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/markdown/LexicalMarkdown.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction LexicalAutoFocusPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    editor.focus();\n  }, [editor]);\n  return null;\n}\n\nmodule.exports = LexicalAutoFocusPlugin;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalAutoFocusPlugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalAutoFocusPlugin =  true ? __webpack_require__(/*! ./LexicalAutoFocusPlugin.dev.js */ \"./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js\") : 0\nmodule.exports = LexicalAutoFocusPlugin;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalAutoFocusPlugin.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalComposer.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = React.useMemo(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError\n    } = initialConfig;\n    const context = LexicalComposerContext.createLexicalComposerContext(null, theme);\n    let editor = initialEditor || null;\n\n    if (editor === null) {\n      const newEditor = lexical.createEditor({\n        context,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        readOnly: true,\n        theme\n      });\n      editor = newEditor;\n    }\n\n    return [editor, context];\n  }, // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffect(() => {\n    const isReadOnly = initialConfig.readOnly;\n    const [editor] = composerContext;\n    editor.setReadOnly(isReadOnly || false); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, children);\n}\n\nmodule.exports = LexicalComposer;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalComposer.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalComposer.js":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalComposer =  true ? __webpack_require__(/*! ./LexicalComposer.dev.js */ \"./node_modules/@lexical/react/LexicalComposer.dev.js\") : 0\nmodule.exports = LexicalComposer;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalComposer.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalComposerContext.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar react = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst LexicalComposerContext = /*#__PURE__*/react.createContext(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = react.useContext(LexicalComposerContext);\n\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n\n  return composerContext;\n}\n\nexports.LexicalComposerContext = LexicalComposerContext;\nexports.createLexicalComposerContext = createLexicalComposerContext;\nexports.useLexicalComposerContext = useLexicalComposerContext;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalComposerContext.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalComposerContext.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalComposerContext =  true ? __webpack_require__(/*! ./LexicalComposerContext.dev.js */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.js\") : 0\nmodule.exports = LexicalComposerContext;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalComposerContext.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalContentEditable.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar React = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction LexicalContentEditable({\n  ariaActiveDescendantID,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaExpanded,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwneeID,\n  ariaRequired,\n  autoCapitalize,\n  autoComplete,\n  autoCorrect,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  testid\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isReadOnly, setReadOnly] = React.useState(true);\n  const ref = React.useCallback(rootElement => {\n    editor.setRootElement(rootElement);\n  }, [editor]);\n  useLayoutEffect(() => {\n    setReadOnly(editor.isReadOnly());\n    return editor.registerReadOnlyListener(currentIsReadOnly => {\n      setReadOnly(currentIsReadOnly);\n    });\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    \"aria-activedescendant\": isReadOnly ? null : ariaActiveDescendantID,\n    \"aria-autocomplete\": isReadOnly ? null : ariaAutoComplete,\n    \"aria-controls\": isReadOnly ? null : ariaControls,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-expanded\": isReadOnly ? null : role === 'combobox' ? !!ariaExpanded : null,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": isReadOnly ? null : ariaOwneeID,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    autoComplete: autoComplete,\n    autoCorrect: autoCorrect,\n    className: className,\n    contentEditable: !isReadOnly,\n    \"data-testid\": testid,\n    id: id,\n    ref: ref,\n    role: isReadOnly ? null : role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex\n  });\n}\n\nmodule.exports = LexicalContentEditable;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalContentEditable.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalContentEditable.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalContentEditable =  true ? __webpack_require__(/*! ./LexicalContentEditable.dev.js */ \"./node_modules/@lexical/react/LexicalContentEditable.dev.js\") : 0\nmodule.exports = LexicalContentEditable;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalContentEditable.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar history = __webpack_require__(/*! @lexical/history */ \"./node_modules/@lexical/history/LexicalHistory.js\");\nvar react = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = react.useMemo(() => externalHistoryState || history.createEmptyHistoryState(), [externalHistoryState]);\n  react.useEffect(() => {\n    return history.registerHistory(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction HistoryPlugin({\n  externalHistoryState\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useHistory(editor, externalHistoryState);\n  return null;\n}\n\nexports.createEmptyHistoryState = history.createEmptyHistoryState;\nexports.HistoryPlugin = HistoryPlugin;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalHistoryPlugin.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHistoryPlugin =  true ? __webpack_require__(/*! ./LexicalHistoryPlugin.dev.js */ \"./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js\") : 0\nmodule.exports = LexicalHistoryPlugin;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalHistoryPlugin.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand();\n\nfunction HorizontalRuleComponent() {\n  return /*#__PURE__*/React.createElement(\"hr\", null);\n}\n\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n\n  static importDOM() {\n    return {\n      hr: node => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n\n  createDOM() {\n    const div = document.createElement('div');\n    div.style.display = 'contents';\n    return div;\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  isTopLevel() {\n    return true;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, null);\n  }\n\n}\n\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\n\nfunction $createHorizontalRuleNode() {\n  return new HorizontalRuleNode();\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalHorizontalRuleNode.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHorizontalRuleNode =  true ? __webpack_require__(/*! ./LexicalHorizontalRuleNode.dev.js */ \"./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js\") : 0\nmodule.exports = LexicalHorizontalRuleNode;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalLinkPlugin.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalLinkPlugin.dev.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar link = __webpack_require__(/*! @lexical/link */ \"./node_modules/@lexical/link/LexicalLink.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction toggleLink(url) {\n  const selection = lexical.$getSelection();\n\n  if (selection !== null) {\n    lexical.$setSelection(selection);\n  }\n\n  const sel = lexical.$getSelection();\n\n  if (sel !== null) {\n    const nodes = sel.extract();\n\n    if (url === null) {\n      // Remove LinkNodes\n      nodes.forEach(node => {\n        const parent = node.getParent();\n\n        if (link.$isLinkNode(parent)) {\n          const children = parent.getChildren();\n\n          for (let i = 0; i < children.length; i++) {\n            parent.insertBefore(children[i]);\n          }\n\n          parent.remove();\n        }\n      });\n    } else {\n      // Add or merge LinkNodes\n      if (nodes.length === 1) {\n        const firstNode = nodes[0]; // if the first node is a LinkNode or if its\n        // parent is a LinkNode, we update the URL.\n\n        if (link.$isLinkNode(firstNode)) {\n          firstNode.setURL(url);\n          return;\n        } else {\n          const parent = firstNode.getParent();\n\n          if (link.$isLinkNode(parent)) {\n            // set parent to be the current linkNode\n            // so that other nodes in the same parent\n            // aren't handled separately below.\n            parent.setURL(url);\n            return;\n          }\n        }\n      }\n\n      let prevParent = null;\n      let linkNode = null;\n      nodes.forEach(node => {\n        const parent = node.getParent();\n\n        if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n          return;\n        }\n\n        if (!parent.is(prevParent)) {\n          prevParent = parent;\n          linkNode = link.$createLinkNode(url);\n\n          if (link.$isLinkNode(parent)) {\n            if (node.getPreviousSibling() === null) {\n              parent.insertBefore(linkNode);\n            } else {\n              parent.insertAfter(linkNode);\n            }\n          } else {\n            node.insertBefore(linkNode);\n          }\n        }\n\n        if (link.$isLinkNode(node)) {\n          if (linkNode !== null) {\n            const children = node.getChildren();\n\n            for (let i = 0; i < children.length; i++) {\n              linkNode.append(children[i]);\n            }\n          }\n\n          node.remove();\n          return;\n        }\n\n        if (linkNode !== null) {\n          linkNode.append(node);\n        }\n      });\n    }\n  }\n}\n\nfunction LinkPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.LinkNode])) {\n      throw new Error('LinkPlugin: LinkNode not registered on editor');\n    }\n  }, [editor]);\n  react.useEffect(() => {\n    return editor.registerCommand(link.TOGGLE_LINK_COMMAND, payload => {\n      const url = payload;\n      toggleLink(url);\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR);\n  }, [editor]);\n  return null;\n}\n\nmodule.exports = LinkPlugin;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalLinkPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalLinkPlugin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalLinkPlugin =  true ? __webpack_require__(/*! ./LexicalLinkPlugin.dev.js */ \"./node_modules/@lexical/react/LexicalLinkPlugin.dev.js\") : 0\nmodule.exports = LexicalLinkPlugin;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalLinkPlugin.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalListPlugin.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.dev.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar list = __webpack_require__(/*! @lexical/list */ \"./node_modules/@lexical/list/LexicalList.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction useList(editor) {\n  react.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n      const hasHandledIndention = list.indentList();\n\n      if (hasHandledIndention) {\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n      const hasHandledIndention = list.outdentList();\n\n      if (hasHandledIndention) {\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.INSERT_ORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'ol');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.INSERT_UNORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'ul');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.REMOVE_LIST_COMMAND, () => {\n      list.removeList(editor);\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n      const hasHandledInsertParagraph = list.$handleListInsertParagraph();\n\n      if (hasHandledInsertParagraph) {\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW));\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction ListPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useList(editor);\n  return null;\n}\n\nmodule.exports = ListPlugin;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalListPlugin.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalListPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalListPlugin =  true ? __webpack_require__(/*! ./LexicalListPlugin.dev.js */ \"./node_modules/@lexical/react/LexicalListPlugin.dev.js\") : 0\nmodule.exports = LexicalListPlugin;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalListPlugin.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar markdown = __webpack_require__(/*! @lexical/markdown */ \"./node_modules/@lexical/markdown/LexicalMarkdown.js\");\nvar LexicalHorizontalRuleNode = __webpack_require__(/*! @lexical/react/LexicalHorizontalRuleNode */ \"./node_modules/@lexical/react/LexicalHorizontalRuleNode.js\");\nvar react = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction useMarkdownShortcuts(editor) {\n  react.useEffect(() => {\n    return markdown.registerMarkdownShortcuts(editor, LexicalHorizontalRuleNode.$createHorizontalRuleNode);\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction LexicalMarkdownShortcutPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useMarkdownShortcuts(editor);\n  return null;\n}\n\nmodule.exports = LexicalMarkdownShortcutPlugin;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMarkdownShortcutPlugin =  true ? __webpack_require__(/*! ./LexicalMarkdownShortcutPlugin.dev.js */ \"./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js\") : 0\nmodule.exports = LexicalMarkdownShortcutPlugin;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"react\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction OnChangePlugin({\n  ignoreInitialChange = true,\n  ignoreSelectionChange = false,\n  onChange\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useLayoutEffect(() => {\n    if (onChange) {\n      return editor.registerUpdateListener(({\n        editorState,\n        dirtyElements,\n        dirtyLeaves,\n        prevEditorState\n      }) => {\n        if (ignoreSelectionChange && dirtyElements.size === 0 && dirtyLeaves.size === 0) {\n          return;\n        }\n\n        if (ignoreInitialChange && prevEditorState.isEmpty()) {\n          return;\n        }\n\n        onChange(editorState, editor);\n      });\n    }\n  }, [editor, ignoreInitialChange, ignoreSelectionChange, onChange]);\n  return null;\n}\n\nmodule.exports = OnChangePlugin;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalOnChangePlugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalOnChangePlugin.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalOnChangePlugin =  true ? __webpack_require__(/*! ./LexicalOnChangePlugin.dev.js */ \"./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js\") : 0\nmodule.exports = LexicalOnChangePlugin;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalOnChangePlugin.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar React = __webpack_require__(/*! react */ \"react\");\nvar text = __webpack_require__(/*! @lexical/text */ \"./node_modules/@lexical/text/LexicalText.js\");\nvar reactDom = __webpack_require__(/*! react-dom */ \"react-dom\");\nvar dragon = __webpack_require__(/*! @lexical/dragon */ \"./node_modules/@lexical/dragon/LexicalDragon.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"./node_modules/@lexical/rich-text/LexicalRichText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction useLexicalCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing())));\n  useLayoutEffect(() => {\n    return editor.registerUpdateListener(({\n      editorState\n    }) => {\n      const isComposing = editor.isComposing();\n      const currentCanShowPlaceholder = editorState.read(text.$canShowPlaceholderCurry(isComposing));\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    });\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction useDecorators(editor) {\n  const [decorators, setDecorators] = React.useState(() => editor.getDecorators()); // Subscribe to changes\n\n  useLayoutEffect(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      reactDom.flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]); // Return decorators defined as React Portals\n\n  return React.useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = decorators[nodeKey];\n      const element = editor.getElementByKey(nodeKey);\n\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/reactDom.createPortal(reactDecorator, element));\n      }\n    }\n\n    return decoratedPortals;\n  }, [decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction useRichTextSetup(editor, initialEditorState) {\n  useLayoutEffect(() => {\n    return utils.mergeRegister(richText.registerRichText(editor, initialEditorState), dragon.registerDragonSupport(editor)); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction RichTextPlugin({\n  contentEditable,\n  placeholder,\n  initialEditorState\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const showPlaceholder = useLexicalCanShowPlaceholder(editor);\n  useRichTextSetup(editor, initialEditorState);\n  const decorators = useDecorators(editor);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, showPlaceholder && placeholder, decorators);\n}\n\nmodule.exports = RichTextPlugin;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalRichTextPlugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalRichTextPlugin =  true ? __webpack_require__(/*! ./LexicalRichTextPlugin.dev.js */ \"./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js\") : 0\nmodule.exports = LexicalRichTextPlugin;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/react/LexicalRichTextPlugin.js?");

/***/ }),

/***/ "./node_modules/@lexical/rich-text/LexicalRichText.dev.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.dev.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar clipboard = __webpack_require__(/*! @lexical/clipboard */ \"./node_modules/@lexical/clipboard/LexicalClipboard.js\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Convoluted logic to make this work with Flow. Order matters.\nconst options = {\n  tag: 'history-merge'\n};\nconst setEditorOptions = options;\nconst updateOptions = options;\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  } // Mutation\n\n\n  insertNewAfter() {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock);\n    return newBlock;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n}\nfunction $createQuoteNode() {\n  return new QuoteNode();\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\nclass HeadingNode extends lexical.ElementNode {\n  static getType() {\n    return 'heading';\n  }\n\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n\n  getTag() {\n    return this.__tag;\n  } // View\n\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n\n    if (classNames !== undefined) {\n      // $FlowFixMe: intentional cast\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      })\n    };\n  } // Mutation\n\n\n  insertNewAfter() {\n    const newElement = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n}\n\nfunction convertHeadingElement(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5') {\n    node = $createHeadingNode(nodeName);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createHeadingNode(headingTag) {\n  return new HeadingNode(headingTag);\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\n\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = lexical.$getRoot();\n      const firstChild = root.getFirstChild();\n\n      if (firstChild === null) {\n        const paragraph = lexical.$createParagraphNode();\n        root.append(paragraph);\n        const activeElement = document.activeElement;\n\n        if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, updateOptions);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, setEditorOptions);\n          break;\n        }\n\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, setEditorOptions);\n          break;\n        }\n\n      case 'function':\n        {\n          editor.update(initialEditorState, updateOptions);\n          break;\n        }\n    }\n  }\n}\n\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event.clipboardData;\n\n    if (clipboardData != null && lexical.$isRangeSelection(selection)) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  });\n}\n\nfunction onCopyForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const clipboardData = event.clipboardData;\n    const selection = lexical.$getSelection();\n\n    if (selection !== null) {\n      if (clipboardData != null) {\n        const htmlString = clipboard.getHtmlContent(editor);\n        const lexicalString = clipboard.$getLexicalContent(editor);\n\n        if (htmlString !== null) {\n          clipboardData.setData('text/html', htmlString);\n        }\n\n        if (lexicalString !== null) {\n          clipboardData.setData('application/x-lexical-editor', lexicalString);\n        }\n\n        clipboardData.setData('text/plain', selection.getTextContent());\n      }\n    }\n  });\n}\n\nfunction onCutForRichText(event, editor) {\n  onCopyForRichText(event, editor);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    }\n  });\n}\n\nfunction registerRichText(editor, initialEditorState) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const isBackward = payload;\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const isBackward = payload;\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const isBackward = payload;\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const eventOrText = payload;\n\n    if (typeof eventOrText === 'string') {\n      selection.insertText(eventOrText);\n    } else {\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const format = payload;\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const nodes = selection.getNodes();\n\n    for (const node of nodes) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(node);\n      element.setFormat(format);\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const selectStart = payload;\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    } // Handle code blocks\n\n\n    const anchor = selection.anchor;\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(anchor.getNode());\n\n    if (parentBlock.canInsertTab()) {\n      editor.dispatchCommand(lexical.INSERT_TEXT_COMMAND, '\\t');\n    } else {\n      if (parentBlock.getIndent() !== 10) {\n        parentBlock.setIndent(parentBlock.getIndent() + 1);\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    } // Handle code blocks\n\n\n    const anchor = selection.anchor;\n    const anchorNode = anchor.getNode();\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(anchor.getNode());\n\n    if (parentBlock.canInsertTab()) {\n      const textContent = anchorNode.getTextContent();\n      const character = textContent[anchor.offset - 1];\n\n      if (character === '\\t') {\n        editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n      }\n    } else {\n      if (parentBlock.getIndent() !== 0) {\n        parentBlock.setIndent(parentBlock.getIndent() - 1);\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, payload => {\n    const selection$1 = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, payload => {\n    const selection$1 = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const event = payload;\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n\n    if (selection.isCollapsed() && anchor.offset === 0) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchor.getNode());\n\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const event = payload;\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      event.preventDefault();\n\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_TAB_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const event = payload;\n    event.preventDefault();\n    return editor.dispatchCommand(event.shiftKey ? lexical.OUTDENT_CONTENT_COMMAND : lexical.INDENT_CONTENT_COMMAND);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    } // TODO: Make drag and drop work at some point.\n\n\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    } // TODO: Make drag and drop work at some point.\n\n\n    const event = payload;\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.$isGridSelection(selection)) {\n      const event = payload;\n      onCopyForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.$isGridSelection(selection)) {\n      const event = payload;\n      onCutForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  initializeEditor(editor, initialEditorState);\n  return removeListener;\n}\n\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.registerRichText = registerRichText;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/rich-text/LexicalRichText.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/rich-text/LexicalRichText.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalRichText =  true ? __webpack_require__(/*! ./LexicalRichText.dev.js */ \"./node_modules/@lexical/rich-text/LexicalRichText.dev.js\") : 0\nmodule.exports = LexicalRichText;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/rich-text/LexicalRichText.js?");

/***/ }),

/***/ "./node_modules/@lexical/selection/LexicalSelection.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst cssToStyles = new Map();\n\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor;\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    clone.__children = Array.from(latest.__children);\n    clone.__format = latest.__format;\n    clone.__indent = latest.__indent;\n    clone.__dir = latest.__dir;\n  } else if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    clone.__format = latest.__format;\n    clone.__style = latest.__style;\n    clone.__mode = latest.__mode;\n    clone.__detail = latest.__detail;\n  } // $FlowFixMe\n\n\n  return clone;\n}\n\nfunction $getIndexFromPossibleClone(node, parent, nodeMap) {\n  const parentClone = nodeMap.get(parent.getKey());\n\n  if (lexical.$isElementNode(parentClone)) {\n    return parentClone.__children.indexOf(node.getKey());\n  }\n\n  return node.getIndexWithinParent();\n}\n\nfunction $getParentAvoidingExcludedElements(node) {\n  let parent = node.getParent();\n\n  while (parent !== null && parent.excludeFromCopy()) {\n    parent = parent.getParent();\n  }\n\n  return parent;\n}\n\nfunction $copyLeafNodeBranchToRoot(leaf, startingOffset, isLeftSide, range, nodeMap) {\n  let node = leaf;\n  let offset = startingOffset;\n\n  while (node !== null) {\n    const parent = $getParentAvoidingExcludedElements(node);\n\n    if (parent === null) {\n      break;\n    }\n\n    if (!lexical.$isElementNode(node) || !node.excludeFromCopy()) {\n      const key = node.getKey();\n      let clone = nodeMap.get(key);\n      const needsClone = clone === undefined;\n\n      if (needsClone) {\n        clone = $cloneWithProperties(node);\n        nodeMap.set(key, clone);\n      }\n\n      if (lexical.$isTextNode(clone) && !clone.isSegmented() && !clone.isToken()) {\n        clone.__text = clone.__text.slice(isLeftSide ? offset : 0, isLeftSide ? undefined : offset);\n      } else if (lexical.$isElementNode(clone)) {\n        clone.__children = clone.__children.slice(isLeftSide ? offset : 0, isLeftSide ? undefined : offset + 1);\n      }\n\n      if (lexical.$isRootNode(parent)) {\n        if (needsClone) {\n          // We only want to collect a range of top level nodes.\n          // So if the parent is the root, we know this is a top level.\n          range.push(key);\n        }\n\n        break;\n      }\n    }\n\n    offset = $getIndexFromPossibleClone(node, parent, nodeMap);\n    node = parent;\n  }\n}\n\nfunction errGetLatestOnClone() {\n  {\n    throw Error(`getLatest() on clone node`);\n  }\n}\n\nfunction $cloneContents(selection) {\n  const clone = $cloneContentsImpl(selection);\n\n  {\n    const nodeMap = clone.nodeMap;\n\n    for (let i = 0; i < nodeMap.length; i++) {\n      const node = nodeMap[i][1]; // $FlowFixMe[method-unbinding]\n\n      if (node.getLatest === errGetLatestOnClone) {\n        continue;\n      }\n\n      Object.setPrototypeOf(node, Object.create(Object.getPrototypeOf(node), {\n        getLatest: {\n          configurable: true,\n          enumerable: true,\n          value: errGetLatestOnClone,\n          writable: true\n        }\n      }));\n    }\n  }\n\n  return clone;\n}\n\nfunction $cloneContentsImpl(selection) {\n  if (lexical.$isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorOffset = anchor.getCharacterOffset();\n    const focusOffset = focus.getCharacterOffset();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const anchorNodeParent = anchorNode.getParentOrThrow(); // Handle a single text node extraction\n\n    if (anchorNode === focusNode && lexical.$isTextNode(anchorNode) && (anchorNodeParent.canBeEmpty() || anchorNodeParent.getChildrenSize() > 1)) {\n      const clonedFirstNode = $cloneWithProperties(anchorNode);\n      const isBefore = focusOffset > anchorOffset;\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      clonedFirstNode.__text = clonedFirstNode.__text.slice(startOffset, endOffset);\n      const key = clonedFirstNode.getKey();\n      return {\n        nodeMap: [[key, clonedFirstNode]],\n        range: [key]\n      };\n    }\n\n    const nodes = selection.getNodes();\n\n    if (nodes.length === 0) {\n      return {\n        nodeMap: [],\n        range: []\n      };\n    } // Check if we can use the parent of the nodes, if the\n    // parent can't be empty, then it's important that we\n    // also copy that element node along with its children.\n\n\n    let nodesLength = nodes.length;\n    const firstNode = nodes[0];\n    const firstNodeParent = firstNode.getParent();\n\n    if (firstNodeParent !== null && (!firstNodeParent.canBeEmpty() || lexical.$isRootNode(firstNodeParent))) {\n      const parentChildren = firstNodeParent.__children;\n      const parentChildrenLength = parentChildren.length;\n\n      if (parentChildrenLength === nodesLength) {\n        let areTheSame = true;\n\n        for (let i = 0; i < parentChildren.length; i++) {\n          if (parentChildren[i] !== nodes[i].__key) {\n            areTheSame = false;\n            break;\n          }\n        }\n\n        if (areTheSame) {\n          nodesLength++;\n          nodes.push(firstNodeParent);\n        }\n      }\n    }\n\n    const lastNode = nodes[nodesLength - 1];\n    const isBefore = anchor.isBefore(focus);\n    const nodeMap = new Map();\n    const range = []; // Do first node to root\n\n    $copyLeafNodeBranchToRoot(firstNode, isBefore ? anchorOffset : focusOffset, true, range, nodeMap); // Copy all nodes between\n\n    for (let i = 0; i < nodesLength; i++) {\n      const node = nodes[i];\n      const key = node.getKey();\n\n      if (!nodeMap.has(key) && (!lexical.$isElementNode(node) || !node.excludeFromCopy())) {\n        const clone = $cloneWithProperties(node);\n\n        if (lexical.$isRootNode(node.getParent())) {\n          range.push(node.getKey());\n        }\n\n        nodeMap.set(key, clone);\n      }\n    } // Do last node to root\n\n\n    $copyLeafNodeBranchToRoot(lastNode, isBefore ? focusOffset : anchorOffset, false, range, nodeMap);\n    return {\n      nodeMap: Array.from(nodeMap.entries()),\n      range\n    };\n  } else if (lexical.$isGridSelection(selection)) {\n    const nodeMap = selection.getNodes().map(node => {\n      const nodeKey = node.getKey();\n      const clone = $cloneWithProperties(node);\n      return [nodeKey, clone];\n    });\n    return {\n      nodeMap,\n      range: [selection.gridKey]\n    };\n  }\n\n  {\n    throw Error(`TODO`);\n  }\n}\n\nfunction getStyleObjectFromCSS(css) {\n  return cssToStyles.get(css) || null;\n}\n\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\nfunction $patchNodeStyle(node, patch) {\n  const prevStyles = getStyleObjectFromCSS(node.getStyle());\n  const newStyles = prevStyles ? { ...prevStyles,\n    ...patch\n  } : patch;\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  node.setStyle(newCSSText);\n  cssToStyles.set(newCSSText, newStyles);\n}\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  let startOffset;\n  let endOffset;\n  const isBefore = anchor.isBefore(focus);\n  startOffset = isBefore ? anchorOffset : focusOffset;\n  endOffset = isBefore ? focusOffset : anchorOffset; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (startOffset === firstNode.getTextContentSize()) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (firstNode.is(lastNode)) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchNodeStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchNodeStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode)) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        [, firstNode] = firstNode.splitText(startOffset);\n        startOffset = 0;\n      }\n\n      $patchNodeStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // if the entire last node isn't selected, split it\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchNodeStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchNodeStyle(selectedNode, patch);\n      }\n    }\n  }\n}\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same font size.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n    lastOffset = lastNode.getChildrenSize();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootNode(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.__children.length === 0) {\n      node.remove();\n    }\n\n    node = parentNode;\n  }\n}\n\nfunction $wrapLeafNodesInElements(selection, createElement, wrappingElement) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n\n  if (nodesLength === 0) {\n    const anchor = selection.anchor;\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootNode(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedLeafNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedLeafNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedLeafNodes.add(child.getKey());\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      elements.push(createElement());\n      node.remove();\n    }\n  }\n\n  if (wrappingElement) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  } // If our target is the root, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n\n  if (lexical.$isRootNode(target)) {\n    const firstChild = target.getFirstChild();\n\n    if (lexical.$isElementNode(firstChild)) {\n      target = firstChild;\n    }\n\n    if (firstChild === null) {\n      if (wrappingElement) {\n        target.append(wrappingElement);\n      } else {\n        for (let i = 0; i < elements.length; i++) {\n          const element = elements[i];\n          target.append(element);\n        }\n      }\n    } else {\n      if (wrappingElement) {\n        firstChild.insertBefore(wrappingElement);\n      } else {\n        for (let i = 0; i < elements.length; i++) {\n          const element = elements[i];\n          firstChild.insertBefore(element);\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    const clonedSelection = prevSelection.clone();\n    clonedSelection.dirty = true;\n    lexical.$setSelection(clonedSelection);\n  } else {\n    selection.dirty = true;\n  }\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getDecoratorNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated();\n}\n\nexports.$cloneContents = $cloneContents;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$wrapLeafNodesInElements = $wrapLeafNodesInElements;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/selection/LexicalSelection.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/selection/LexicalSelection.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalSelection =  true ? __webpack_require__(/*! ./LexicalSelection.dev.js */ \"./node_modules/@lexical/selection/LexicalSelection.dev.js\") : 0\nmodule.exports = LexicalSelection;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/selection/LexicalSelection.js?");

/***/ }),

/***/ "./node_modules/@lexical/table/LexicalTable.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.dev.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/* eslint-disable sort-keys-fix/sort-keys-fix */\nconst TableCellHeaderStates = {\n  NO_STATUS: 0,\n  ROW: 1,\n  COLUMN: 2,\n  BOTH: 3\n};\nclass TableCellNode extends lexical.GridCellNode {\n  static getType() {\n    return 'tablecell';\n  }\n\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(colSpan, key);\n    this.__headerState = headerState;\n    this.__width = width;\n  }\n\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      const maxWidth = 700;\n      const colCount = this.getParentOrThrow().getChildrenSize();\n      element.style.border = '1px solid black';\n      element.style.width = `${this.getWidth() || Math.max(90, maxWidth / colCount)}px`;\n      element.style.verticalAlign = 'top';\n      element.style.textAlign = 'start';\n\n      if (this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n\n  getWidth() {\n    return this.getLatest().__width;\n  }\n\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n\n    self.__headerState = self.__headerState;\n    return self;\n  }\n\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width;\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n}\nfunction convertTableCellNodeElement(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS);\n  return {\n    node: tableCellNode,\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !lexical.$isElementNode(lexicalNode)) {\n        const paragraphNode = lexical.$createParagraphNode();\n\n        if (lexical.$isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n\n      return lexicalNode;\n    }\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return new TableCellNode(headerState, colSpan, width);\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass TableRowNode extends lexical.GridRowNode {\n  static getType() {\n    return 'tablerow';\n  }\n\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('tr');\n\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n\n  getHeight() {\n    return this.getLatest().__height;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n}\nfunction convertTableRowElement(domNode) {\n  return {\n    node: $createTableRowNode()\n  };\n}\nfunction $createTableRowNode(height) {\n  return new TableRowNode(height);\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst getSelection = () => window.getSelection();\n\nvar getDOMSelection = getSelection;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nif (CAN_USE_DOM) {\n  const disableNativeSelectionUi = document.createElement('style');\n  disableNativeSelectionUi.innerHTML = `\n    table.disable-selection {\n      -webkit-touch-callout: none;\n      -webkit-user-select: none; \n      -khtml-user-select: none; \n      -moz-user-select: none; \n      -ms-user-select: none; \n      user-select: none;\n    }\n  \n    .disable-selection span::selection{\n      background-color: transparent;\n    }\n    .disable-selection br::selection{\n      background-color: transparent;\n    }\n  `;\n\n  if (document.body) {\n    document.body.append(disableNativeSelectionUi);\n  }\n}\n\nclass TableSelection {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.startX = -1;\n    this.startY = -1;\n    this.currentX = -1;\n    this.currentY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.grid = {\n      cells: [],\n      columns: 0,\n      rows: 0\n    };\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTableGrid();\n  }\n\n  getGrid() {\n    return this.grid;\n  }\n\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n\n  trackTableGrid() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n\n          if (nodeName === 'TABLE' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n\n        if (!gridNeedsRedraw) {\n          return;\n        }\n\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n\n        this.grid = getTableGrid(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      this.grid = getTableGrid(tableElement);\n      observer.observe(tableElement, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n\n  clearHighlight() {\n    this.editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const grid = getTableGrid(tableElement);\n      this.isHighlightingCells = false;\n      this.startX = -1;\n      this.startY = -1;\n      this.currentX = -1;\n      this.currentY = -1;\n      this.gridSelection = null;\n      this.anchorCellNodeKey = null;\n      this.focusCellNodeKey = null;\n      this.anchorCell = null;\n      this.focusCell = null;\n      this.hasHijackedSelectionStyles = false;\n      $updateDOMForSelection(grid, null);\n      lexical.$setSelection(null);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND);\n      this.enableHighlightStyle();\n    });\n  }\n\n  enableHighlightStyle() {\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n\n  disableHighlightStyle() {\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      tableElement.classList.add('disable-selection');\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n\n  adjustFocusCellForSelection(cell, ignoreStart = false) {\n    this.editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      const domSelection = getDOMSelection();\n\n      if (this.anchorCell !== null) {\n        // Collapse the selection\n        domSelection.setBaseAndExtent(this.anchorCell.elem, 0, cell.elem, 0);\n      }\n\n      if (!this.isHighlightingCells && (this.startX !== cellX || this.startY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.currentX && cellY === this.currentY) {\n        return;\n      }\n\n      this.currentX = cellX;\n      this.currentY = cellY;\n\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n        if (this.gridSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode)) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.gridSelection = lexical.$createGridSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.gridSelection.set(this.tableNodeKey, // $FlowFixMe This is not null, as you can see in the statement above.\n          this.anchorCellNodeKey, this.focusCellNodeKey);\n          lexical.$setSelection(this.gridSelection);\n          this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND);\n          $updateDOMForSelection(this.grid, this.gridSelection);\n        }\n      }\n    });\n  }\n\n  setAnchorCellForSelection(cell) {\n    this.editor.update(() => {\n      this.anchorCell = cell;\n      this.startX = cell.x;\n      this.startY = cell.y;\n      const domSelection = getDOMSelection();\n      domSelection.setBaseAndExtent(cell.elem, 0, cell.elem, 0);\n      const anchorTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.gridSelection = lexical.$createGridSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      } // This is to make Flow play ball.\n\n\n      const formatSelection = lexical.$createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      lexical.$setSelection(selection);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND);\n    });\n  }\n\n  clearText() {\n    this.editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n      if (selectedNodes.length === this.grid.columns * this.grid.rows) {\n        tableNode.selectPrevious(); // Delete entire table\n\n        tableNode.remove();\n        this.clearHighlight();\n        return;\n      }\n\n      selectedNodes.forEach(cellNode => {\n        if (lexical.$isElementNode(cellNode)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          const textNode = lexical.$createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(this.grid, null);\n      lexical.$setSelection(null);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND);\n    });\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nfunction applyTableHandlers(tableNode, tableElement, editor) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n\n  const tableSelection = new TableSelection(editor, tableNode.getKey());\n  attachTableSelectionToTableElement(tableElement, tableSelection);\n  let isMouseDown = false;\n  let isRangeSelectionHijacked = false;\n  tableElement.addEventListener('dblclick', event => {\n    // $FlowFixMe: event.target is always a Node on the DOM\n    const cell = getCellFromTarget(event.target);\n\n    if (cell !== null) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      tableSelection.setAnchorCellForSelection(cell);\n      tableSelection.adjustFocusCellForSelection(cell, true);\n      isMouseDown = false;\n    }\n  }); // This is the anchor of the selection.\n\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      } // $FlowFixMe: event.target is always a Node on the DOM\n\n\n      const cell = getCellFromTarget(event.target);\n\n      if (cell !== null) {\n        tableSelection.setAnchorCellForSelection(cell);\n        document.addEventListener('mouseup', () => {\n          isMouseDown = false;\n        }, {\n          capture: true,\n          once: true\n        });\n      }\n    }, 0);\n  }); // This is adjusting the focus of the selection.\n\n  tableElement.addEventListener('mousemove', event => {\n    if (isRangeSelectionHijacked) {\n      event.preventDefault();\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n    }\n\n    if (isMouseDown) {\n      // $FlowFixMe: event.target is always a Node on the DOM\n      const cell = getCellFromTarget(event.target);\n\n      if (cell !== null) {\n        const cellX = cell.x;\n        const cellY = cell.y;\n\n        if (isMouseDown && (tableSelection.startX !== cellX || tableSelection.startY !== cellY || tableSelection.isHighlightingCells)) {\n          event.preventDefault();\n          isMouseDown = true;\n          tableSelection.adjustFocusCellForSelection(cell);\n        }\n      }\n    }\n  });\n  tableElement.addEventListener('mouseup', event => {\n    if (isMouseDown) {\n      isMouseDown = false;\n    }\n  }); // Select entire table at this point, when grid selection is ready.\n\n  tableElement.addEventListener('mouseleave', event => {\n    if (isMouseDown) {\n      return;\n    }\n  }); // Clear selection when clicking outside of dom.\n\n  const mouseDownCallback = event => {\n    isMouseDown = true;\n\n    if (event.button !== 0) {\n      return;\n    }\n\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (lexical.$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey && rootElement.contains(event.target)) {\n        return tableSelection.clearHighlight();\n      }\n    });\n  };\n\n  window.addEventListener('mousedown', mouseDownCallback);\n  tableSelection.listenersToRemove.add(() => window.removeEventListener('mousedown', mouseDownCallback));\n\n  const mouseUpCallback = event => {\n    isMouseDown = false;\n  };\n\n  window.addEventListener('mouseup', mouseUpCallback);\n  tableSelection.listenersToRemove.add(() => window.removeEventListener('mouseup', mouseUpCallback));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    const event = payload;\n    const direction = 'down';\n\n    if (lexical.$isRangeSelection(selection)) {\n      if (selection.isCollapsed()) {\n        const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n        if (!$isTableCellNode(tableCellNode)) {\n          return false;\n        }\n\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        const elementParentNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n\n        if (elementParentNode == null) {\n          throw new Error('Expected BlockNode Parent');\n        }\n\n        const lastChild = tableCellNode.getLastChild();\n        const isSelectionInLastBlock = lastChild && elementParentNode.isParentOf(lastChild) || elementParentNode === lastChild;\n\n        if (isSelectionInLastBlock || event.shiftKey) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          event.stopPropagation(); // Start Selection\n\n          if (event.shiftKey) {\n            tableSelection.setAnchorCellForSelection(tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid));\n            return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n          }\n\n          return selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n        }\n      }\n    } else if (lexical.$isGridSelection(selection) && event.shiftKey) {\n      const tableCellNode = selection.focus.getNode();\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    const event = payload;\n    const direction = 'up';\n\n    if (lexical.$isRangeSelection(selection)) {\n      if (selection.isCollapsed()) {\n        const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n        if (!$isTableCellNode(tableCellNode)) {\n          return false;\n        }\n\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        const elementParentNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n\n        if (elementParentNode == null) {\n          throw new Error('Expected BlockNode Parent');\n        }\n\n        const lastChild = tableCellNode.getLastChild();\n        const isSelectionInLastBlock = lastChild && elementParentNode.isParentOf(lastChild) || elementParentNode === lastChild;\n\n        if (isSelectionInLastBlock || event.shiftKey) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          event.stopPropagation(); // Start Selection\n\n          if (event.shiftKey) {\n            tableSelection.setAnchorCellForSelection(tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid));\n            return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n          }\n\n          return selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n        }\n      }\n    } else if (lexical.$isGridSelection(selection) && event.shiftKey) {\n      const tableCellNode = selection.focus.getNode();\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    const event = payload;\n    const direction = 'backward';\n\n    if (lexical.$isRangeSelection(selection)) {\n      if (selection.isCollapsed()) {\n        const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n        if (!$isTableCellNode(tableCellNode)) {\n          return false;\n        }\n\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        const elementParentNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n\n        if (elementParentNode == null) {\n          throw new Error('Expected BlockNode Parent');\n        }\n\n        if (selection.anchor.offset === 0 || event.shiftKey) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          event.stopPropagation(); // Start Selection\n\n          if (event.shiftKey) {\n            tableSelection.setAnchorCellForSelection(tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid));\n            return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n          }\n\n          return selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n        }\n      }\n    } else if (lexical.$isGridSelection(selection) && event.shiftKey) {\n      const tableCellNode = selection.focus.getNode();\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    const event = payload;\n    const direction = 'forward';\n\n    if (lexical.$isRangeSelection(selection)) {\n      if (selection.isCollapsed()) {\n        const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n        if (!$isTableCellNode(tableCellNode)) {\n          return false;\n        }\n\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        const elementParentNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n\n        if (elementParentNode == null) {\n          throw new Error('Expected BlockNode Parent');\n        }\n\n        if (selection.anchor.offset === selection.anchor.getNode().getTextContentSize() || event.shiftKey) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          event.stopPropagation(); // Start Selection\n\n          if (event.shiftKey) {\n            tableSelection.setAnchorCellForSelection(tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid));\n            return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n          }\n\n          return selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n        }\n      }\n    } else if (lexical.$isGridSelection(selection) && event.shiftKey) {\n      const tableCellNode = selection.focus.getNode();\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.$isGridSelection(selection)) {\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      if (selection.isCollapsed() && selection.anchor.offset === 0 && selection.anchor.getNode().getPreviousSiblings().length === 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.$isGridSelection(selection)) {\n      const event = payload;\n      event.preventDefault();\n      event.stopPropagation();\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.$isGridSelection(selection)) {\n      tableSelection.formatCells(payload);\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.INSERT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.$isGridSelection(selection)) {\n      tableSelection.clearHighlight();\n      return false;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_TAB_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const event = payload;\n\n      if (selection.isCollapsed()) {\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        event.preventDefault();\n        selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.SELECTION_CHANGE_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (selection && lexical.$isRangeSelection(selection) && !selection.isCollapsed()) {\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const containsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n\n      if (containsPartialTable) {\n        const isBackward = selection.isBackward();\n        const modifiedSelection = lexical.$createRangeSelection();\n        const tableIndex = tableNode.getIndexWithinParent();\n        const parentKey = tableNode.getParentOrThrow().getKey();\n        modifiedSelection.anchor.set(selection.anchor.key, selection.anchor.offset, selection.anchor.type); // Set selection to before or after table on the root node.\n\n        modifiedSelection.focus.set(parentKey, isBackward ? tableIndex - 1 : tableIndex + 1, 'element');\n        isRangeSelectionHijacked = true;\n        lexical.$setSelection(modifiedSelection);\n        $addHighlightStyleToTable(tableSelection);\n        return true;\n      }\n    }\n\n    if (tableSelection.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(tableSelection);\n      isRangeSelectionHijacked = false;\n    } else if (!tableSelection.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(tableSelection);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  return tableSelection;\n}\nfunction attachTableSelectionToTableElement(tableElement, tableSelection) {\n  // $FlowFixMe\n  tableElement[LEXICAL_ELEMENT_KEY] = tableSelection;\n}\nfunction getTableSelectionFromTableElement(tableElement) {\n  // $FlowFixMe\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getCellFromTarget(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // $FlowFixMe: internal field\n      const cell = currentNode._cell;\n\n      if (cell === undefined) {\n        return null;\n      }\n\n      return cell;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nfunction getTableGrid(tableElement) {\n  const cells = [];\n  const grid = {\n    cells,\n    columns: 0,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  cells.length = 0;\n\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      // $FlowFixMe: TD is always an HTMLElement\n      const elem = currentNode;\n      const cell = {\n        elem,\n        highlighted: false,\n        x,\n        y\n      }; // $FlowFixMe: internal field\n\n      currentNode._cell = cell;\n\n      if (cells[y] === undefined) {\n        cells[y] = [];\n      }\n\n      cells[y][x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n\n    const sibling = currentNode.nextSibling;\n\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n\n    const parent = currentNode.parentNode;\n\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n\n      if (parentSibling == null) {\n        break;\n      }\n\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(grid, selection) {\n  const highlightedCells = [];\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachGridCell(grid, (cell, lexicalNode) => {\n    const elem = cell.elem;\n\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      elem.style.setProperty('background-color', 'rgb(172, 206, 247)');\n      elem.style.setProperty('caret-color', 'transparent');\n      highlightedCells.push(cell);\n    } else {\n      cell.highlighted = false;\n      elem.style.removeProperty('background-color');\n      elem.style.removeProperty('caret-color');\n\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n  return highlightedCells;\n}\nfunction $forEachGridCell(grid, cb) {\n  const {\n    cells\n  } = grid;\n\n  for (let y = 0; y < cells.length; y++) {\n    const row = cells[y];\n\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      const lexicalNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    const elem = cell.elem;\n    cell.highlighted = true;\n    elem.style.setProperty('background-color', 'rgb(172, 206, 247)');\n    elem.style.setProperty('caret-color', 'transparent');\n  });\n}\nfunction $removeHighlightStyleToTable(tableSelection) {\n  tableSelection.enableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    elem.style.removeProperty('background-color');\n    elem.style.removeProperty('caret-color');\n\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\n\nconst selectGridNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      {\n        const isForward = direction === 'forward';\n\n        if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid));\n        } else {\n          if (y !== (isForward ? tableSelection.grid.rows - 1 : 0)) {\n            selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableSelection.grid.columns - 1, y + (isForward ? 1 : -1), tableSelection.grid));\n          } else if (!isForward) {\n            tableNode.selectPrevious();\n          } else {\n            tableNode.selectNext();\n          }\n        }\n\n        return true;\n      }\n\n    case 'up':\n      {\n        if (y !== 0) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableSelection.grid));\n        } else {\n          tableNode.selectPrevious();\n        }\n\n        return true;\n      }\n\n    case 'down':\n      {\n        if (y !== tableSelection.grid.rows - 1) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableSelection.grid));\n        } else {\n          tableNode.selectNext();\n        }\n\n        return true;\n      }\n  }\n\n  return false;\n};\n\nconst adjustFocusNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      {\n        const isForward = direction === 'forward';\n\n        if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n          tableSelection.adjustFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid));\n        }\n\n        return true;\n      }\n\n    case 'up':\n      {\n        if (y !== 0) {\n          tableSelection.adjustFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y - 1, tableSelection.grid));\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n    case 'down':\n      {\n        if (y !== tableSelection.grid.rows - 1) {\n          tableSelection.adjustFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y + 1, tableSelection.grid));\n          return true;\n        } else {\n          return false;\n        }\n      }\n  }\n\n  return false;\n};\n\nfunction $isSelectionInTable(selection, tableNode) {\n  if (lexical.$isRangeSelection(selection) || lexical.$isGridSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n\n  return false;\n}\n\nfunction selectTableCellNode(tableCell) {\n  const possibleParagraph = tableCell.getChildren().find(n => lexical.$isParagraphNode(n));\n\n  if (lexical.$isParagraphNode(possibleParagraph)) {\n    possibleParagraph.selectEnd();\n  } else {\n    tableCell.selectEnd();\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass TableNode extends lexical.GridNode {\n  static getType() {\n    return 'table';\n  }\n\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n\n  static importDOM() {\n    return {\n      table: node => ({\n        conversion: convertTableElement,\n        priority: 0\n      })\n    };\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    utils.addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  exportDOM(editor) {\n    return { ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          tBody.append(...tableElement.children);\n          const firstRow = this.getFirstChildOrThrow();\n\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n\n          const colCount = firstRow.getChildrenSize();\n\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          } //$FlowFixMe This function does exist and is supported by major browsers.\n\n\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n\n  canExtractContents() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  getCordsFromCellNode(tableCellNode, grid) {\n    if (!grid) {\n      throw Error(`Grid not found.`);\n    }\n\n    const {\n      rows,\n      cells\n    } = grid;\n\n    for (let y = 0; y < rows; y++) {\n      const row = cells[y];\n\n      if (row == null) {\n        throw new Error(`Row not found at y:${y}`);\n      }\n\n      const x = row.findIndex(({\n        elem\n      }) => {\n        const cellNode = lexical.$getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n\n    throw new Error('Cell not found in table.');\n  }\n\n  getCellFromCords(x, y, grid) {\n    if (!grid) {\n      throw Error(`Grid not found.`);\n    }\n\n    const {\n      cells\n    } = grid;\n    const row = cells[y];\n\n    if (row == null) {\n      return null;\n    }\n\n    const cell = row[x];\n\n    if (cell == null) {\n      return null;\n    }\n\n    return cell;\n  }\n\n  getCellFromCordsOrThrow(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n\n    return cell;\n  }\n\n  getCellNodeFromCords(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (cell == null) {\n      return null;\n    }\n\n    const node = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n\n    return null;\n  }\n\n  getCellNodeFromCordsOrThrow(x, y, grid) {\n    const node = this.getCellNodeFromCords(x, y, grid);\n\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n\n    return node;\n  }\n\n  canSelectBefore() {\n    return true;\n  }\n\n}\nfunction $getElementGridForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n\n  return getTableGrid(tableElement);\n}\nfunction convertTableElement(domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return new TableNode();\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n\n      if (includeHeaders) {\n        if (iRow === 0) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0) headerState |= TableCellHeaderStates.COLUMN;\n      }\n\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = lexical.$createParagraphNode();\n      paragraphNode.append(lexical.$createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n\n    tableNode.append(tableRowNode);\n  }\n\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableCellNode(n));\n\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableRowNode(n));\n\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableNode(n));\n\n  if ($isTableNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, grid) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, grid);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, grid),\n    below: tableNode.getCellNodeFromCords(x, y + 1, grid),\n    left: tableNode.getCellNodeFromCords(x - 1, y, grid),\n    right: tableNode.getCellNodeFromCords(x + 1, y, grid)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n\n  const targetRowNode = tableRows[targetIndex];\n\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || null;\n\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append(lexical.$createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n\n  return tableNode;\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount) {\n  const tableRows = tableNode.getChildren();\n\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        let headerState = TableCellHeaderStates.NO_STATUS;\n\n        if (r === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append(lexical.$createParagraphNode());\n        const tableRowChildren = currentTableRowNode.getChildren();\n\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n\n        const targetCell = tableRowChildren[targetIndex];\n\n        if (shouldInsertAfter) {\n          targetCell.insertAfter(newTableCell);\n        } else {\n          targetCell.insertBefore(newTableCell);\n        }\n      }\n    }\n  }\n\n  return tableNode;\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n\n  return tableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst INSERT_TABLE_COMMAND = lexical.createCommand();\n\nexports.$createTableCellNode = $createTableCellNode;\nexports.$createTableNode = $createTableNode;\nexports.$createTableNodeWithDimensions = $createTableNodeWithDimensions;\nexports.$createTableRowNode = $createTableRowNode;\nexports.$deleteTableColumn = $deleteTableColumn;\nexports.$getElementGridForTableNode = $getElementGridForTableNode;\nexports.$getTableCellNodeFromLexicalNode = $getTableCellNodeFromLexicalNode;\nexports.$getTableColumnIndexFromTableCellNode = $getTableColumnIndexFromTableCellNode;\nexports.$getTableNodeFromLexicalNodeOrThrow = $getTableNodeFromLexicalNodeOrThrow;\nexports.$getTableRowIndexFromTableCellNode = $getTableRowIndexFromTableCellNode;\nexports.$getTableRowNodeFromTableCellNodeOrThrow = $getTableRowNodeFromTableCellNodeOrThrow;\nexports.$insertTableColumn = $insertTableColumn;\nexports.$insertTableRow = $insertTableRow;\nexports.$isTableCellNode = $isTableCellNode;\nexports.$isTableNode = $isTableNode;\nexports.$isTableRowNode = $isTableRowNode;\nexports.$removeTableRowAtIndex = $removeTableRowAtIndex;\nexports.INSERT_TABLE_COMMAND = INSERT_TABLE_COMMAND;\nexports.TableCellHeaderStates = TableCellHeaderStates;\nexports.TableCellNode = TableCellNode;\nexports.TableNode = TableNode;\nexports.TableRowNode = TableRowNode;\nexports.TableSelection = TableSelection;\nexports.applyTableHandlers = applyTableHandlers;\nexports.getCellFromTarget = getCellFromTarget;\nexports.getTableSelectionFromTableElement = getTableSelectionFromTableElement;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/table/LexicalTable.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/table/LexicalTable.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTable =  true ? __webpack_require__(/*! ./LexicalTable.dev.js */ \"./node_modules/@lexical/table/LexicalTable.dev.js\") : 0\nmodule.exports = LexicalTable;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/table/LexicalTable.js?");

/***/ }),

/***/ "./node_modules/@lexical/text/LexicalText.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n\n      currentCharacters += characters;\n    }\n\n    const sibling = node.getNextSibling();\n\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n\n    let parent = node.getParent();\n\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n\n      parent = parent.getParent();\n    }\n\n    break;\n  }\n\n  return null;\n} // Return text content for child text nodes.  Each non-text node is separated by input string.\n// Caution, this function creates a string and should not be used within a tight loop.\n// Use $getNodeWithOffsetsFromJoinedTextNodesFromElementNode below to convert\n// indexes in the return string back into their corresponding node and offsets.\n\nfunction $joinTextNodesInElementNode(elementNode, separator, stopAt) {\n  let textContent = '';\n  const children = elementNode.getChildren();\n  const length = children.length;\n\n  for (let i = 0; i < length; ++i) {\n    const child = children[i];\n\n    if (lexical.$isTextNode(child)) {\n      const childTextContent = child.getTextContent();\n\n      if (child.is(stopAt.node)) {\n        if (stopAt.offset > childTextContent.length) {\n          {\n            throw Error(`Node ${child.__key} and selection point do not match.`);\n          }\n        }\n\n        textContent += child.getTextContent().substr(0, stopAt.offset);\n        break;\n      } else {\n        textContent += childTextContent;\n      }\n    } else {\n      textContent += separator;\n    }\n  }\n\n  return textContent;\n} // This function converts the offsetInJoinedText to\n// a node and offset result or null if not found.\n// This function is to be used in conjunction with joinTextNodesInElementNode above.\n// The joinedTextContent should be return value from joinTextNodesInElementNode.\n//\n// The offsetInJoinedText is relative to the entire string which\n// itself is relevant to the parent ElementNode.\n//\n// Example:\n// Given a Paragraph with 2 TextNodes. The first is Hello, the second is World.\n// The joinedTextContent would be \"HelloWorld\"\n// The offsetInJoinedText might be for the letter \"e\" = 1 or \"r\" = 7.\n// The return values would be {TextNode1, 1} or {TextNode2,2}, respectively.\n\nfunction $findNodeWithOffsetFromJoinedText(offsetInJoinedText, joinedTextLength, separatorLength, elementNode) {\n  const children = elementNode.getChildren();\n  const childrenLength = children.length;\n  let runningLength = 0;\n  let isPriorNodeTextNode = false;\n\n  for (let i = 0; i < childrenLength; ++i) {\n    // We must examine the offsetInJoinedText that is located\n    // at the length of the string.\n    // For example, given \"hello\", the length is 5, yet\n    // the caller still wants the node + offset at the\n    // right edge of the \"o\".\n    if (runningLength > joinedTextLength) {\n      break;\n    }\n\n    const child = children[i];\n    const isChildNodeTestNode = lexical.$isTextNode(child);\n    const childContentLength = isChildNodeTestNode ? child.getTextContent().length : separatorLength;\n    const newRunningLength = runningLength + childContentLength;\n    const isJoinedOffsetWithinNode = isPriorNodeTextNode === false && runningLength === offsetInJoinedText || runningLength === 0 && runningLength === offsetInJoinedText || runningLength < offsetInJoinedText && offsetInJoinedText <= newRunningLength;\n\n    if (isJoinedOffsetWithinNode && lexical.$isTextNode(child)) {\n      // Check isTextNode again for flow.\n      return {\n        node: child,\n        offset: offsetInJoinedText - runningLength\n      };\n    }\n\n    runningLength = newRunningLength;\n    isPriorNodeTextNode = isChildNodeTestNode;\n  }\n\n  return null;\n}\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n\n  let text = $rootTextContentCurry();\n\n  if (trim) {\n    text = text.trim();\n  }\n\n  return text === '';\n}\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\nfunction $rootTextContentCurry() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n\n  if (childrenLength > 1) {\n    return false;\n  }\n\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n\n    if (lexical.$isElementNode(topBlock)) {\n      if (topBlock.__type !== 'paragraph') {\n        return false;\n      }\n\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n\n      if (match === null) {\n        return;\n      }\n\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n\n      let nodeToReplace;\n\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n\n      const replacementNode = createNode(nodeToReplace);\n      nodeToReplace.replace(replacementNode);\n\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n\n    const nextSibling = node.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling); // This may have already been converted in the previous block\n\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findNodeWithOffsetFromJoinedText = $findNodeWithOffsetFromJoinedText;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$joinTextNodesInElementNode = $joinTextNodesInElementNode;\nexports.$rootTextContentCurry = $rootTextContentCurry;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/text/LexicalText.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/text/LexicalText.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalText =  true ? __webpack_require__(/*! ./LexicalText.dev.js */ \"./node_modules/@lexical/text/LexicalText.dev.js\") : 0\nmodule.exports = LexicalText;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/text/LexicalText.js?");

/***/ }),

/***/ "./node_modules/@lexical/utils/LexicalUtils.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (className != null && typeof className === 'string') {\n      element.classList.add(...className.split(' '));\n    }\n  });\n}\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    element.classList.remove(...className.split(' '));\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let node_ = node;\n  let depth = 0;\n\n  while ((node_ = node_.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return parent;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.mergeRegister = mergeRegister;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/utils/LexicalUtils.dev.js?");

/***/ }),

/***/ "./node_modules/@lexical/utils/LexicalUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalUtils =  true ? __webpack_require__(/*! ./LexicalUtils.dev.js */ \"./node_modules/@lexical/utils/LexicalUtils.dev.js\") : 0\nmodule.exports = LexicalUtils;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/@lexical/utils/LexicalUtils.js?");

/***/ }),

/***/ "./src/Beeeditor/Editor.tsx":
/*!**********************************!*\
  !*** ./src/Beeeditor/Editor.tsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposer */ \"./node_modules/@lexical/react/LexicalComposer.js\");\n/* harmony import */ var _lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalContentEditable */ \"./node_modules/@lexical/react/LexicalContentEditable.js\");\n/* harmony import */ var _lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalRichTextPlugin */ \"./node_modules/@lexical/react/LexicalRichTextPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/react/LexicalHistoryPlugin */ \"./node_modules/@lexical/react/LexicalHistoryPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _lexical_react_LexicalAutoFocusPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/react/LexicalAutoFocusPlugin */ \"./node_modules/@lexical/react/LexicalAutoFocusPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalAutoFocusPlugin__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalAutoFocusPlugin__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _lexical_react_LexicalLinkPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/react/LexicalLinkPlugin */ \"./node_modules/@lexical/react/LexicalLinkPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalLinkPlugin__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalLinkPlugin__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _lexical_react_LexicalListPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/react/LexicalListPlugin */ \"./node_modules/@lexical/react/LexicalListPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalListPlugin__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalListPlugin__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _lexical_react_LexicalMarkdownShortcutPlugin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/react/LexicalMarkdownShortcutPlugin */ \"./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalMarkdownShortcutPlugin__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalMarkdownShortcutPlugin__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lexical/react/LexicalOnChangePlugin */ \"./node_modules/@lexical/react/LexicalOnChangePlugin.js\");\n/* harmony import */ var _lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lexical/code */ \"./node_modules/@lexical/code/LexicalCode.js\");\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_lexical_code__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lexical/rich-text */ \"./node_modules/@lexical/rich-text/LexicalRichText.js\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_lexical_rich_text__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lexical/list */ \"./node_modules/@lexical/list/LexicalList.js\");\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_lexical_list__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @lexical/link */ \"./node_modules/@lexical/link/LexicalLink.js\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_lexical_link__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _lexical_table__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @lexical/table */ \"./node_modules/@lexical/table/LexicalTable.js\");\n/* harmony import */ var _lexical_table__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_lexical_table__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _plugins_GetStartPlugin__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/GetStartPlugin */ \"./src/Beeeditor/plugins/GetStartPlugin.tsx\");\n/* harmony import */ var _plugins_CodeHighlightPlugin__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugins/CodeHighlightPlugin */ \"./src/Beeeditor/plugins/CodeHighlightPlugin.tsx\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! . */ \"./src/Beeeditor/index.ts\");\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./styles.css */ \"./src/Beeeditor/styles.css\");\n// react\n // third\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n // project\n\n\n\n\n\nvar Editor = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {\n  var editorConfig = {\n    theme: ___WEBPACK_IMPORTED_MODULE_17__.theme,\n    onError: function onError(error) {\n      throw error;\n    },\n    nodes: [_lexical_rich_text__WEBPACK_IMPORTED_MODULE_11__.HeadingNode, _lexical_list__WEBPACK_IMPORTED_MODULE_12__.ListNode, _lexical_list__WEBPACK_IMPORTED_MODULE_12__.ListItemNode, _lexical_rich_text__WEBPACK_IMPORTED_MODULE_11__.QuoteNode, _lexical_code__WEBPACK_IMPORTED_MODULE_10__.CodeNode, _lexical_code__WEBPACK_IMPORTED_MODULE_10__.CodeHighlightNode, _lexical_table__WEBPACK_IMPORTED_MODULE_14__.TableNode, _lexical_table__WEBPACK_IMPORTED_MODULE_14__.TableCellNode, _lexical_table__WEBPACK_IMPORTED_MODULE_14__.TableRowNode, _lexical_link__WEBPACK_IMPORTED_MODULE_13__.AutoLinkNode, _lexical_link__WEBPACK_IMPORTED_MODULE_13__.LinkNode]\n  };\n\n  var onChange = function onChange() {};\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((_lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_1___default()), {\n    initialConfig: editorConfig\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, props.children), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((_lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_3___default()), {\n    contentEditable: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((_lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_2___default()), {\n      className: \"beeeditor-input\"\n    }),\n    placeholder: null\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_4__.HistoryPlugin, null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((_lexical_react_LexicalAutoFocusPlugin__WEBPACK_IMPORTED_MODULE_5___default()), null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((_lexical_react_LexicalListPlugin__WEBPACK_IMPORTED_MODULE_7___default()), null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((_lexical_react_LexicalLinkPlugin__WEBPACK_IMPORTED_MODULE_6___default()), null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((_lexical_react_LexicalMarkdownShortcutPlugin__WEBPACK_IMPORTED_MODULE_8___default()), null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement((_lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_9___default()), {\n    onChange: onChange\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_plugins_GetStartPlugin__WEBPACK_IMPORTED_MODULE_15__[\"default\"], {\n    defaultValue: props.defaultValue,\n    ref: ref\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_plugins_CodeHighlightPlugin__WEBPACK_IMPORTED_MODULE_16__[\"default\"], null));\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Editor);\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./src/Beeeditor/Editor.tsx?");

/***/ }),

/***/ "./src/Beeeditor/index.ts":
/*!********************************!*\
  !*** ./src/Beeeditor/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _Editor__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"theme\": () => (/* binding */ theme)\n/* harmony export */ });\n/* harmony import */ var _Editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Editor */ \"./src/Beeeditor/Editor.tsx\");\n\nvar theme = {\n  heading: {\n    h1: 'beeeditor-heading-h1',\n    h2: 'beeeditor-heading-h2',\n    h3: 'beeeditor-heading-h3',\n    h4: 'beeeditor-heading-h4',\n    h5: 'beeeditor-heading-h5'\n  },\n  code: 'beeeditor-code',\n  quote: 'beeeditor-quote',\n  list: {\n    listitem: 'beeeditor-list-listitem'\n  }\n};\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./src/Beeeditor/index.ts?");

/***/ }),

/***/ "./src/Beeeditor/plugins/CodeHighlightPlugin.tsx":
/*!*******************************************************!*\
  !*** ./src/Beeeditor/plugins/CodeHighlightPlugin.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/code */ \"./node_modules/@lexical/code/LexicalCode.js\");\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lexical_code__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\nvar CodeHighlightPlugin = function CodeHighlightPlugin() {\n  var _useLexicalComposerCo = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)(),\n      _useLexicalComposerCo2 = _slicedToArray(_useLexicalComposerCo, 1),\n      editor = _useLexicalComposerCo2[0];\n\n  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {\n    return (0,_lexical_code__WEBPACK_IMPORTED_MODULE_0__.registerCodeHighlighting)(editor);\n  }, [editor]);\n  return null;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CodeHighlightPlugin);\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./src/Beeeditor/plugins/CodeHighlightPlugin.tsx?");

/***/ }),

/***/ "./src/Beeeditor/plugins/GetStartPlugin.tsx":
/*!**************************************************!*\
  !*** ./src/Beeeditor/plugins/GetStartPlugin.tsx ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\nvar GetStartPlugin = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(function (props, ref) {\n  var _useLexicalComposerCo = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0__.useLexicalComposerContext)(),\n      _useLexicalComposerCo2 = _slicedToArray(_useLexicalComposerCo, 1),\n      editor = _useLexicalComposerCo2[0];\n  /**\n   * ref\n   */\n\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle)(ref, function () {\n    return {\n      getEditorState: function getEditorState() {\n        return editor.getEditorState();\n      }\n    };\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    try {\n      props.defaultValue && editor.setEditorState(editor.parseEditorState(props.defaultValue));\n    } catch (error) {\n      console.error(error);\n    }\n  }, [editor, props.defaultValue]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    var _props$isReadonly;\n\n    editor.setReadOnly((_props$isReadonly = props.isReadonly) !== null && _props$isReadonly !== void 0 ? _props$isReadonly : false);\n  }, [editor, props.isReadonly]);\n  return null;\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GetStartPlugin);\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./src/Beeeditor/plugins/GetStartPlugin.tsx?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _Beeeditor__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _Beeeditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Beeeditor */ \"./src/Beeeditor/index.ts\");\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./src/index.ts?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/Beeeditor/styles.css":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/Beeeditor/styles.css ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".beeeditor-input {\\n  padding: 16px;\\n  background-color: white;\\n  min-height: 500px;\\n}\\n\\n.beeeditor-input:focus-visible {\\n  outline: none;\\n}\\n\\n.beeeditor-heading-h1 {\\n  font-size: 28px;\\n  line-height: 36px;\\n  font-weight: 700;\\n}\\n\\n.beeeditor-heading-h2 {\\n  font-size: 24px;\\n  line-height: 32px;\\n  font-weight: 700;\\n}\\n\\n.beeeditor-heading-h3 {\\n  font-size: 20px;\\n  line-height: 28px;\\n  font-weight: 700;\\n}\\n\\n.beeeditor-heading-h4 {\\n  font-size: 16px;\\n  line-height: 24px;\\n  font-weight: 700;\\n}\\n\\n.beeeditor-heading-h5 {\\n  font-size: 15px;\\n  line-height: 24px;\\n  font-weight: 700;\\n}\\n\\n.beeeditor-code {\\n  background-color: rgb(240, 242, 245);\\n  font-family: Menlo, Consolas, Monaco, monospace;\\n  display: block;\\n  padding: 8px 8px 8px 52px;\\n  line-height: 1.53;\\n  font-size: 13px;\\n  margin: 8px 0 8px 0;\\n  tab-size: 2;\\n  overflow-x: auto;\\n  position: relative;\\n}\\n\\n.beeeditor-code:before {\\n  content: attr(data-gutter);\\n  position: absolute;\\n  background-color: #eee;\\n  left: 0;\\n  top: 0;\\n  border-right: 1px solid #ccc;\\n  padding: 8px;\\n  color: #777;\\n  white-space: pre-wrap;\\n  text-align: right;\\n  min-width: 25px;\\n}\\n\\n.beeeditor-code:after {\\n  content: attr(data-highlight-language);\\n  top: 0;\\n  right: 3px;\\n  padding: 3px;\\n  font-size: 10px;\\n  text-transform: uppercase;\\n  position: absolute;\\n  color: rgba(0, 0, 0, 0.5);\\n}\\n\\n.beeeditor-quote {\\n  margin: 0;\\n  margin-left: 20px;\\n  font-size: 15px;\\n  color: rgb(101, 103, 107);\\n  border-left-color: rgb(206, 208, 212);\\n  border-left-width: 4px;\\n  border-left-style: solid;\\n  padding-left: 16px;\\n}\\n\\n.beeeditor-list-listitem {\\n  margin: 8px 32px 8px 32px;\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./src/Beeeditor/styles.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/lexical/Lexical.dev.js":
/*!*********************************************!*\
  !*** ./node_modules/lexical/Lexical.dev.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst getSelection = () => window.getSelection();\n\nvar getDOMSelection = getSelection;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3; // Reconciling\n\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2; // Text node modes\n\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\nconst IS_INERT = 3; // Text node formatting\n\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6; // Text node details\n\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1; // Element node formatting\n\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4; // Reconciliation\n\nconst ZERO_WIDTH_CHAR = '\\u200b';\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT\n};\nconst TEXT_MODE_TO_TYPE = {\n  inert: IS_INERT,\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n// export const IS_CHROME: boolean = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nlet keyCounter = 0;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\n\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  const nodeName = activeElement !== null ? activeElement.nodeName : null;\n  return !$isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) || nodeName !== 'INPUT' && nodeName !== 'TEXTAREA';\n}\n\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor\n    anchorDOM !== null && isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    // $FlowFixMe: internal field\n    const editor = currentNode.__lexicalEditor;\n\n    if (editor != null && !editor.isReadOnly()) {\n      return editor;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n\n  return null;\n}\nfunction $isTokenOrInert(node) {\n  return node.isToken() || node.isInert();\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      // $FlowFixMe: this is a Text\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n\n  editorState._nodeMap.set(key, node); // TODO Split this function into leaf/element\n\n\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n\n  editor._cloneNotNeeded.add(key);\n\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\n\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n\n    const node = nodeMap.get(nextParentKey);\n\n    if (node === undefined) {\n      break;\n    }\n\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\nfunction removeFromParent(writableNode) {\n  const oldParent = writableNode.getParent();\n\n  if (oldParent !== null) {\n    const writableParent = oldParent.getWritable();\n    const children = writableParent.__children;\n    const index = children.indexOf(writableNode.__key);\n\n    if (index === -1) {\n      {\n        throw Error(`Node is not a child of its parent`);\n      }\n    }\n\n    internalMarkSiblingsAsDirty(writableNode);\n    children.splice(index, 1);\n  }\n} // Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\n\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  editor._compositionKey = compositionKey;\n\n  if (previousCompositionKey !== null) {\n    const node = $getNodeByKey(previousCompositionKey);\n\n    if (node !== null) {\n      node.getWritable();\n    }\n  }\n\n  if (compositionKey !== null) {\n    const node = $getNodeByKey(compositionKey);\n\n    if (node !== null) {\n      node.getWritable();\n    }\n  }\n}\nfunction $getCompositionKey() {\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n\n  const node = editorState._nodeMap.get(key);\n\n  if (node === undefined) {\n    return null;\n  }\n\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor(); // $FlowFixMe: internal field\n\n  const key = dom['__lexicalKey_' + editor._key];\n\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n\n    if (node !== null) {\n      return node;\n    }\n\n    dom = dom.parentNode;\n  }\n\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(view => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n\n    if (editorState.isEmpty()) {\n      return;\n    }\n\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n\n    const nodeMap = editorState._nodeMap;\n\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root' // $FlowFixMe: root is always in our Map\n  );\n}\nfunction $setSelection(selection) {\n  const editorState = getActiveEditorState();\n\n  if (selection !== null && Object.isFrozen(selection)) {\n    console.warn('$setSelection called on frozen selection object. Ensure selection is cloned before passing in.');\n  }\n\n  editorState._selection = selection;\n}\nfunction $flushMutations$1() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n\n    return null;\n  }\n\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\n\nfunction getNodeKeyFromDOM( // Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n\n  while (node != null) {\n    const key = // $FlowFixMe: internal field\n    node['__lexicalKey_' + editor._key];\n\n    if (key !== undefined) {\n      return key;\n    }\n\n    node = node.parentNode;\n  }\n\n  return null;\n}\n\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction $updateSelectedTextFromDOM(editor, compositionEndEvent) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection();\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n\n  if (anchorNode !== null && anchorNode.nodeType === DOM_TEXT_TYPE) {\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n\n    if ($isTextNode(node)) {\n      let textContent = anchorNode.nodeValue;\n      const data = compositionEndEvent !== null && compositionEndEvent.data; // Data is intentionally truthy, as we check for boolean, null and empty string.\n\n      if (textContent === ZERO_WIDTH_CHAR && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n\n      $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, compositionEndEvent !== null);\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === ZERO_WIDTH_CHAR) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n\n    const prevTextContent = node.getTextContent();\n\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n\n        if (!IS_SAFARI && !IS_IOS) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              node.remove();\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n\n        return;\n      }\n\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n\n      if ($isTokenOrInert(node) || $getCompositionKey() !== null && !isComposing || // Check if character was added at the start, and we need\n      // to clear this input from occuring as that action wasn't\n      // permitted.\n      parent !== null && $isRangeSelection(prevSelection) && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0) {\n        node.markDirty();\n        return;\n      }\n\n      const selection = $getSelection();\n\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\n\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  const shouldInsertTextBefore = offset === 0 && (!node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken);\n  const shouldInsertTextAfter = node.getTextContentSize() === offset && (!node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken);\n  return shouldInsertTextBefore || shouldInsertTextAfter;\n}\n\nfunction $shouldPreventDefaultAndInsertText(selection, text, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const domSelection = getDOMSelection();\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = getActiveEditor().getElementByKey(anchorKey);\n  return anchorKey !== focus.key || // If we're working with a non-text node.\n  !$isTextNode(anchorNode) || // If we're working with a range that is not during composition.\n  anchor.offset !== focus.offset && !anchorNode.isComposing() || // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  (isBeforeInput || anchorNode.isDirty()) && text.length > 1 || // If the DOM selection element is not the same as the backing node\n  backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n} // Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\n\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\n\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\n\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\n\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\n\nfunction isMoveBackward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveUp(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  const classNames = classNamesTheme[classNameThemeType]; // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesTheme[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n\n  if (!mutatedNodesByType.has(nodeKey)) {\n    mutatedNodesByType.set(nodeKey, mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n\n  return nodesOfType;\n}\n\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\n\nfunction $getDecoratorNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n\n      return possibleNode;\n    }\n  }\n\n  return null;\n}\nfunction isFirefoxClipboardEvents() {\n  const event = window.event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, type, payload) {\n  return triggerCommandListeners(editor, type, payload);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n\n      delete decorators[key];\n    }\n  }\n}\n\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, dirtyNodes) {\n  const children = node.__children;\n  const childrenLength = children.length;\n\n  for (let i = 0; i < childrenLength; i++) {\n    const childKey = children[i];\n    const child = nodeMap.get(childKey);\n\n    if (child !== undefined && child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, dirtyNodes);\n      } // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n\n\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n\n      nodeMap.delete(childKey);\n    }\n  }\n}\n\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n\n      nodeMap.delete(nodeKey);\n    }\n  }\n\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, dirtyElements);\n        } // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n\n\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n\n        nodeMap.delete(nodeKey);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\n\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\n\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  } // Backward\n\n\n  let previousNode;\n\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  } // Forward\n\n\n  let nextNode;\n\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction $createNodeFromParse(parsedNode, parsedNodeMap) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  return internalCreateNodeFromParse(parsedNode, parsedNodeMap, editor, null);\n}\nfunction internalCreateNodeFromParse(parsedNode, parsedNodeMap, editor, parentKey, state = {\n  originalSelection: null\n}) {\n  const nodeType = parsedNode.__type;\n\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`createNodeFromParse: type \"${nodeType}\" + not found`);\n    }\n  } // Check for properties that are editors\n\n\n  for (const property in parsedNode) {\n    const value = parsedNode[property];\n\n    if (value != null && typeof value === 'object') {\n      const parsedEditorState = value.editorState;\n\n      if (parsedEditorState != null) {\n        const nestedEditor = createEditor();\n        nestedEditor._nodes = editor._nodes;\n        nestedEditor._parentEditor = editor._parentEditor;\n        nestedEditor._pendingEditorState = parseEditorState(parsedEditorState, nestedEditor);\n        parsedNode[property] = nestedEditor;\n      }\n    }\n  }\n\n  const NodeKlass = registeredNode.klass;\n  const parsedKey = parsedNode.__key; // We set the parsedKey to undefined before calling clone() so that\n  // we get a new random key assigned.\n\n  parsedNode.__key = undefined;\n  const node = NodeKlass.clone(parsedNode);\n  parsedNode.__key = parsedKey;\n  const key = node.__key;\n\n  if ($isRootNode(node)) {\n    const editorState = getActiveEditorState();\n\n    editorState._nodeMap.set('root', node);\n  }\n\n  node.__parent = parentKey; // We will need to recursively handle the children in the case\n  // of a ElementNode.\n\n  if ($isElementNode(node)) {\n    const children = parsedNode.__children;\n\n    for (let i = 0; i < children.length; i++) {\n      const childKey = children[i];\n      const parsedChild = parsedNodeMap.get(childKey);\n\n      if (parsedChild !== undefined) {\n        const child = internalCreateNodeFromParse(parsedChild, parsedNodeMap, editor, key, state);\n        const newChildKey = child.__key;\n\n        node.__children.push(newChildKey);\n      }\n    }\n\n    node.__indent = parsedNode.__indent;\n    node.__format = parsedNode.__format;\n    node.__dir = parsedNode.__dir;\n  } else if ($isTextNode(node)) {\n    node.__format = parsedNode.__format;\n    node.__style = parsedNode.__style;\n    node.__mode = parsedNode.__mode;\n    node.__detail = parsedNode.__detail;\n  } // The selection might refer to an old node whose key has changed. Produce a\n  // new selection record with the old keys mapped to the new ones.\n\n\n  const originalSelection = state != null ? state.originalSelection : undefined;\n\n  if (originalSelection != null) {\n    let remappedSelection = state.remappedSelection;\n\n    if (originalSelection.type === 'range') {\n      const anchor = originalSelection.anchor;\n      const focus = originalSelection.focus;\n\n      if (remappedSelection == null && (parsedKey === anchor.key || parsedKey === focus.key)) {\n        state.remappedSelection = remappedSelection = {\n          anchor: { ...anchor\n          },\n          focus: { ...focus\n          },\n          type: 'range'\n        };\n      }\n\n      if (remappedSelection != null && remappedSelection.type === 'range') {\n        if (parsedKey === anchor.key) {\n          remappedSelection.anchor.key = key;\n        }\n\n        if (parsedKey === focus.key) {\n          remappedSelection.focus.key = key;\n        }\n      }\n    } else if (originalSelection.type === 'node') {\n      const nodes = originalSelection.nodes;\n      const indexOf = nodes.indexOf(parsedKey);\n\n      if (indexOf !== -1) {\n        if (remappedSelection == null) {\n          state.remappedSelection = remappedSelection = {\n            nodes: [...nodes],\n            type: 'node'\n          };\n        }\n\n        if (remappedSelection.type === 'node') {\n          remappedSelection.nodes.splice(indexOf, 1, key);\n        }\n      }\n    } else if (originalSelection.type === 'grid') {\n      const gridKey = originalSelection.gridKey;\n      const anchorCellKey = originalSelection.anchorCellKey;\n      const focusCellKey = originalSelection.focusCellKey;\n\n      if (remappedSelection == null && (gridKey === parsedKey || gridKey === anchorCellKey || gridKey === focusCellKey)) {\n        state.remappedSelection = remappedSelection = { ...originalSelection,\n          type: 'grid'\n        };\n      }\n\n      if (remappedSelection != null && remappedSelection.type === 'grid') {\n        if (gridKey === parsedKey) {\n          remappedSelection.gridKey = key;\n        }\n\n        if (anchorCellKey === parsedKey) {\n          remappedSelection.anchorCellKey = key;\n        }\n\n        if (focusCellKey === parsedKey) {\n          remappedSelection.focusCellKey = key;\n        }\n      }\n    }\n  }\n\n  return node;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [// $FlowIgnore bad event inheritance\n['keydown', onKeyDown], // $FlowIgnore bad event inheritance\n['compositionstart', onCompositionStart], // $FlowIgnore bad event inheritance\n['compositionend', onCompositionEnd], // $FlowIgnore bad event inheritance\n['input', onInput], // $FlowIgnore bad event inheritance\n['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND]];\n\nif (CAN_USE_BEFORE_INPUT) {\n  // $FlowIgnore bad event inheritance\n  rootElementEvents.push(['beforeinput', onBeforeInput]);\n} else {\n  rootElementEvents.push(['drop', PASS_THROUGH_COMMAND]);\n}\n\nlet lastKeyDownTimeStamp = 0;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromReconcile = false;\n\nfunction onSelectionChange(domSelection, editor, isActive) {\n  if (isSelectionChangeFromReconcile) {\n    isSelectionChangeFromReconcile = false;\n    const {\n      anchorNode,\n      focusNode\n    } = domSelection; // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n\n    if (anchorNode !== null && focusNode !== null && anchorNode.nodeType === DOM_TEXT_TYPE && focusNode.nodeType === DOM_TEXT_TYPE) {\n      return;\n    }\n  }\n\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n\n    const selection = $getSelection(); // Update the selection format\n\n    if ($isRangeSelection(selection) && selection.isCollapsed()) {\n      // Badly interpreted range selection when collapsed - #1482\n      if (domSelection.type === 'Range') {\n        selection.dirty = true;\n      }\n\n      const anchor = selection.anchor;\n\n      if (anchor.type === 'text') {\n        const anchorNode = anchor.getNode();\n        selection.format = anchorNode.getFormat();\n      } else if (anchor.type === 'element') {\n        selection.format = 0;\n      }\n    }\n\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND);\n  });\n} // This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\n\n\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n\n      if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && $getRoot().getChildrenSize() === 1 && anchor.getNode().getTopLevelElementOrThrow().isEmpty()) {\n        const lastSelection = editor.getEditorState()._selection;\n\n        if (lastSelection !== null && selection.is(lastSelection)) {\n          getDOMSelection().removeAllRanges();\n          selection.dirty = true;\n        }\n      }\n    }\n\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\n\nfunction $applyTargetRange(selection, event) {\n  if (event.getTargetRanges) {\n    const targetRange = event.getTargetRanges()[0];\n\n    if (targetRange) {\n      selection.applyDOMRange(targetRange);\n    }\n  }\n}\n\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !$isTokenOrInert(anchorNode) || !$isTokenOrInert(focusNode);\n}\n\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType; // We let the browser do its own thing for composition.\n\n  if (inputType === 'deleteCompositionText' || // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents()) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    // This logic handles insertion of text between different\n    // format text types. We have to detect a change in type\n    // during composition and see if the previous text contains\n    // part of the composed text to work out the actual text that\n    // we need to insert.\n    const composedText = event.data;\n\n    if (composedText) {\n      updateEditor(editor, () => {\n        const selection = $getSelection();\n\n        if ($isRangeSelection(selection)) {\n          const anchor = selection.anchor;\n          const node = anchor.getNode();\n          const prevNode = node.getPreviousSibling();\n\n          if (anchor.offset === 0 && $isTextNode(node) && $isTextNode(prevNode) && node.getTextContent() === ' ' && prevNode.getFormat() !== selection.format) {\n            const prevTextContent = prevNode.getTextContent();\n\n            if (composedText.indexOf(prevTextContent) === 0) {\n              const insertedText = composedText.slice(prevTextContent.length);\n              dispatchCommand(editor, INSERT_TEXT_COMMAND, insertedText);\n              setTimeout(() => {\n                updateEditor(editor, () => {\n                  node.select();\n                });\n              }, ANDROID_COMPOSITION_LATENCY);\n            }\n          }\n        }\n      });\n    }\n\n    return;\n  }\n\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n\n    if (inputType === 'deleteContentBackward') {\n      // Used for Android\n      $setCompositionKey(null);\n      event.preventDefault();\n      lastKeyDownTimeStamp = 0;\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true); // Fixes an Android bug where selection flickers when backspacing\n\n      setTimeout(() => {\n        editor.update(() => {\n          $setCompositionKey(null);\n        });\n      }, ANDROID_COMPOSITION_LATENCY);\n      return;\n    }\n\n    const data = event.data;\n\n    if (!selection.dirty && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode())) {\n      $applyTargetRange(selection, event);\n    }\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (inputType === 'insertText') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND);\n      } else if (data === '\\n\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, data, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_TEXT_COMMAND, data);\n      }\n\n      return;\n    } // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n\n\n    event.preventDefault();\n\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, INSERT_TEXT_COMMAND, event);\n          break;\n        }\n\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_TEXT_COMMAND, event);\n          break;\n        }\n\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND);\n          break;\n        }\n\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND);\n          break;\n        }\n\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND);\n          }\n\n          break;\n        }\n\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND);\n          break;\n        }\n\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND);\n          break;\n        }\n\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND);\n          break;\n        }\n\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, data, false)) {\n      dispatchCommand(editor, INSERT_TEXT_COMMAND, data); // For Android\n\n      if (editor._compositionKey !== null) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      $updateSelectedTextFromDOM(editor, null);\n    } // Also flush any other mutations that might have occurred\n    // since the change.\n\n\n    $flushMutations$1();\n  });\n}\n\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      $setCompositionKey(anchor.key);\n\n      if ( // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || anchor.type === 'element' || !selection.isCollapsed() || selection.anchor.getNode().getFormat() !== selection.format) {\n        // We insert an empty space, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, INSERT_TEXT_COMMAND, ' ');\n      }\n    }\n  });\n}\n\nfunction onCompositionEnd(event, editor) {\n  updateEditor(editor, () => {\n    const compositionKey = editor._compositionKey;\n    $setCompositionKey(null);\n    const data = event.data; // Handle termination of composition.\n\n    if (compositionKey !== null && data != null) {\n      // It can sometimes move to an adjacent DOM node when backspacing.\n      // So check for the empty case.\n      if (data === '') {\n        const node = $getNodeByKey(compositionKey);\n        const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n\n        if (textNode !== null && $isTextNode(node)) {\n          $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n        }\n\n        return;\n      } else if (data[data.length - 1] === '\\n') {\n        const selection = $getSelection();\n\n        if ($isRangeSelection(selection)) {\n          // If the last character is a line break, we also need to insert\n          // a line break.\n          const focus = selection.focus;\n          selection.anchor.set(focus.key, focus.offset, focus.type);\n          dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n          return;\n        }\n      }\n    }\n\n    $updateSelectedTextFromDOM(editor, event);\n  });\n}\n\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n\n  if (editor.isComposing()) {\n    return;\n  }\n\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n\n  if (isMoveForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveUp(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND);\n  }\n}\n\nfunction getRootElementRemoveHandles(rootElement) {\n  // $FlowFixMe: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n\n  if (eventHandles === undefined) {\n    eventHandles = []; // $FlowFixMe: internal field\n\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n\n  return eventHandles;\n} // Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\n\n\nconst activeNestedEditorsMap = new Map();\n\nfunction onDocumentSelectionChange(event) {\n  const selection = getDOMSelection();\n  const nextActiveEditor = getNearestEditorFromDOMNode(selection.anchorNode);\n\n  if (nextActiveEditor === null) {\n    return;\n  } // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n\n\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(selection, prevActiveEditor, false);\n  }\n\n  onSelectionChange(selection, nextActiveEditor, true); // If newly selected editor is nested, then add it to the map, clean map otherwise\n\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\n\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  rootElementsRegistered++; // $FlowFixMe: internal field\n\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (!editor.isReadOnly()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (!editor.isReadOnly()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n\n          case 'blur':\n            return dispatchCommand(editor, BLUR_COMMAND, event);\n\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--; // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  } // $FlowFixMe: internal field\n\n\n  const editor = rootElement.__lexicalEditor;\n\n  if (editor != null) {\n    cleanActiveNestedEditorsMap(editor); // $FlowFixMe: internal field\n\n    rootElement.__lexicalEditor = null;\n  }\n\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  } // $FlowFixMe: internal field\n\n\n  rootElement.__lexicalEventHandles = [];\n}\n\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\n\nfunction markSelectionChangeFromReconcile() {\n  isSelectionChangeFromReconcile = true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\n\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    parentDOM.removeChild(dom);\n  } // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n\n\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n\n  if ($isElementNode(node)) {\n    const children = node.__children;\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\n\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\n\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\n\nfunction setElementIndent(dom, indent) {\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : indent * 40 + 'px');\n}\n\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  }\n}\n\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1); // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n\n    const children = node.__children;\n    const childrenLength = children.length;\n\n    if (childrenLength !== 0) {\n      const endIndex = childrenLength - 1;\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n\n    const format = node.__format;\n\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n\n    reconcileElementTerminatingLineBreak(null, children, dom);\n  } else {\n    const text = node.getTextContent();\n\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      } // Decorators are always non editable\n\n\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n\n      if (node.isInert()) {\n        const domStyle = dom.style;\n        domStyle.pointerEvents = 'none';\n        domStyle.userSelect = 'none';\n        dom.contentEditable = 'false'; // To support Safari\n\n        domStyle.setProperty('-webkit-user-select', 'none');\n      }\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // $FlowFixMe: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\n\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\n\nfunction createChildren(children, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  } // $FlowFixMe: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction isLastChildLineBreakOrDecorator(children, nodeMap) {\n  const childKey = children[children.length - 1];\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node);\n} // If we end an element with a LinkBreakNode, then we need to add an additonal <br>\n\n\nfunction reconcileElementTerminatingLineBreak(prevChildren, nextChildren, dom) {\n  const prevLineBreak = prevChildren !== null && (prevChildren.length === 0 || isLastChildLineBreakOrDecorator(prevChildren, activePrevNodeMap));\n  const nextLineBreak = nextChildren !== null && (nextChildren.length === 0 || isLastChildLineBreakOrDecorator(nextChildren, activeNextNodeMap));\n\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // $FlowFixMe: internal field\n      const element = dom.__lexicalLineBreak;\n\n      if (element != null) {\n        dom.removeChild(element);\n      } // $FlowFixMe: internal field\n\n\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br'); // $FlowFixMe: internal field\n\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\n\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = // $FlowFixMe: internal field\n  dom.__lexicalDirTextContent; // $FlowFixMe: internal field\n\n  const previousDirection = dom.__lexicalDir;\n\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined; // Remove the old theme classes if they exist\n\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' '); // $FlowFixMe: intentional\n\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        } // $FlowFixMe: intentional\n\n\n        classList.remove(...previousDirectionTheme);\n      }\n\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' '); // $FlowFixMe: intentional\n\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n\n          classList.add(...nextDirectionTheme);\n        } // Update direction\n\n\n        dom.dir = direction;\n      }\n\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n\n    activeTextDirection = direction; // $FlowFixMe: internal field\n\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent; // $FlowFixMe: internal field\n\n    dom.__lexicalDir = direction;\n  }\n}\n\nfunction reconcileChildrenWithDirection(prevChildren, nextChildren, element, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevChildren, nextChildren, dom);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\n\nfunction reconcileChildren(prevChildren, nextChildren, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  const prevChildrenLength = prevChildren.length;\n  const nextChildrenLength = nextChildren.length;\n\n  if (prevChildrenLength === 1 && nextChildrenLength === 1) {\n    const prevChildKey = prevChildren[0];\n    const nextChildKey = nextChildren[0];\n\n    if (prevChildKey === nextChildKey) {\n      reconcileNode(prevChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevChildKey);\n      const replacementDOM = createNode(nextChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevChildKey, null);\n    }\n  } else if (prevChildrenLength === 0) {\n    if (nextChildrenLength !== 0) {\n      createChildren(nextChildren, 0, nextChildrenLength - 1, dom, null);\n    }\n  } else if (nextChildrenLength === 0) {\n    if (prevChildrenLength !== 0) {\n      // $FlowFixMe: internal field\n      const lexicalLineBreak = dom.__lexicalLineBreak;\n      const canUseFastPath = lexicalLineBreak == null;\n      destroyChildren(prevChildren, 0, prevChildrenLength - 1, canUseFastPath ? null : dom);\n\n      if (canUseFastPath) {\n        // Fast path for removing DOM nodes\n        dom.textContent = '';\n      }\n    }\n  } else {\n    reconcileNodeChildren(prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom);\n  } // $FlowFixMe: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // $FlowFixMe: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      } // $FlowFixMe: internal field\n\n\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n\n    return dom;\n  }\n\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  } // Update node. If it returns true, we need to unmount and re-create the node\n\n\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n\n    const nextFormat = nextNode.__format;\n\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n\n    const prevChildren = prevNode.__children;\n    const nextChildren = nextNode.__children;\n    const childrenAreDifferent = prevChildren !== nextChildren;\n\n    if (childrenAreDifferent || isDirty) {\n      reconcileChildrenWithDirection(prevChildren, nextChildren, nextNode, dom);\n\n      if (!$isRootNode(nextNode)) {\n        reconcileElementTerminatingLineBreak(prevChildren, nextChildren, dom);\n      }\n    }\n  } else {\n    const text = nextNode.getTextContent();\n\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n\n  return dom;\n}\n\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n\n  pendingDecorators[key] = decorator;\n}\n\nfunction getFirstChild(element) {\n  // $FlowFixMe: firstChild is always null or a Node\n  return element.firstChild;\n}\n\nfunction getNextSibling(element) {\n  // $FlowFixMe: nextSibling is always null or a Node\n  return element.nextSibling;\n}\n\nfunction reconcileNodeChildren(prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n\n          reconcileNode(nextKey, dom);\n        }\n\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\n\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = ''; // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null); // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // $FlowFixMe\n\n  activeEditor$1 = undefined; // $FlowFixMe\n\n  activeEditorNodes = undefined; // $FlowFixMe\n\n  activeDirtyElements = undefined; // $FlowFixMe\n\n  activeDirtyLeaves = undefined; // $FlowFixMe\n\n  activePrevNodeMap = undefined; // $FlowFixMe\n\n  activeNextNodeMap = undefined; // $FlowFixMe\n\n  activeEditorConfig = undefined; // $FlowFixMe\n\n  activePrevKeyToDOMMap = undefined; // $FlowFixMe\n\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\n\nfunction updateEditorState(rootElement, currentEditorState, pendingEditorState, currentSelection, pendingSelection, needsUpdate, editor) {\n  const observer = editor._observer;\n  let reconcileMutatedNodes = null;\n\n  if (needsUpdate && observer !== null) {\n    const dirtyType = editor._dirtyType;\n    const dirtyElements = editor._dirtyElements;\n    const dirtyLeaves = editor._dirtyLeaves;\n    observer.disconnect();\n\n    try {\n      reconcileMutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } finally {\n      observer.observe(rootElement, {\n        characterData: true,\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n\n  const domSelection = getDOMSelection();\n\n  if (domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    reconcileSelection(currentSelection, pendingSelection, editor, domSelection);\n  }\n\n  return reconcileMutatedNodes;\n}\n\nfunction scrollIntoViewIfNeeded(editor, node, rootElement) {\n  const element = // $FlowFixMe: this is valid, as we are checking the nodeType\n  node.nodeType === DOM_TEXT_TYPE ? node.parentNode : node;\n\n  if (element !== null) {\n    const rect = element.getBoundingClientRect();\n\n    if (rect.bottom > window.innerHeight) {\n      element.scrollIntoView(false);\n    } else if (rect.top < 0) {\n      element.scrollIntoView();\n    } else if (rootElement) {\n      const rootRect = rootElement.getBoundingClientRect();\n\n      if (rect.bottom > rootRect.bottom) {\n        element.scrollIntoView(false);\n      } else if (rect.top < rootRect.top) {\n        element.scrollIntoView();\n      }\n    }\n\n    editor._updateTags.add('scroll-into-view');\n  }\n}\n\nfunction reconcileSelection(prevSelection, nextSelection, editor, domSelection) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n  const rootElement = editor._rootElement; // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n\n  if (editor._updateTags.has('collaboration') && activeElement !== rootElement) {\n    return;\n  }\n\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n\n    return;\n  }\n\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n\n  {\n    // Freeze the selection in DEV to prevent accidental mutations\n    Object.freeze(anchor);\n    Object.freeze(focus);\n    Object.freeze(nextSelection);\n  }\n\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n  }\n\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  } // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n\n\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  } // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update.\n\n\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && nextSelection.isCollapsed())) {\n    // If the root element does not have focus, ensure it has focus\n    if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n\n    return;\n  } // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n\n\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n\n    if (nextSelection.isCollapsed() && rootElement === activeElement) {\n      scrollIntoViewIfNeeded(editor, nextAnchorNode, rootElement);\n    }\n\n    markSelectionChangeFromReconcile();\n  } catch (error) {// If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n}\n\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap; // $FlowFixMe: internal field\n\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\n\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key \"${key}\"`);\n    }\n  }\n\n  return element;\n}\n\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key \"${key}\"`);\n    }\n  }\n\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n\n  const transformsArrLength = transformsArr.length;\n\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\n\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined && // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\n\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if ($isTextNode(node) && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtress we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\n\n\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n\n        if ($isTextNode(node) && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n\n        dirtyLeaves.add(nodeKey);\n      }\n\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size; // We want to prioritize node transforms over element transforms\n\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    } // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n\n      if (nodeKey === 'root' || !intentionallyMarkedAsDirty) {\n        continue;\n      }\n\n      const node = nodeMap.get(nodeKey);\n\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\n\nfunction parseEditorState(parsedEditorState, editor) {\n  const nodeMap = new Map();\n  const editorState = new EditorState(nodeMap);\n  const nodeParserState = {\n    originalSelection: parsedEditorState._selection\n  };\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n\n  try {\n    const parsedNodeMap = new Map(parsedEditorState._nodeMap); // $FlowFixMe: root always exists in Map\n\n    const parsedRoot = parsedNodeMap.get('root');\n    internalCreateNodeFromParse(parsedRoot, parsedNodeMap, editor, null\n    /* parentKey */\n    , nodeParserState);\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  editorState._selection = internalCreateSelectionFromParse(nodeParserState.remappedSelection || nodeParserState.originalSelection);\n  return editorState;\n} // This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\n\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap; // $FlowFixMe: this is allowed\n\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  }; // $FlowFixMe: this is allowed\n\n\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  }; // $FlowFixMe: this is allowed\n\n\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\n\nfunction commitPendingUpdates(editor) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n\n  if (rootElement === null || pendingEditorState === null) {\n    return;\n  }\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditor = editor;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false; // We don't want updates to sync block the reconcilation.\n\n  editor._updating = true;\n\n  try {\n    const mutatedNodes = updateEditorState(rootElement, currentEditorState, pendingEditorState, currentSelection, pendingSelection, needsUpdate, editor);\n\n    if (mutatedNodes !== null) {\n      triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes);\n    }\n  } catch (error) {\n    // Report errors\n    editor._onError(error); // Reset editor and restore incoming editor state to the DOM\n\n\n    if (!isAttemptingToRecoverFromReconcilerError) {\n      resetEditor(editor, null, rootElement, pendingEditorState);\n      initMutationObserver(editor);\n      editor._dirtyType = FULL_RECONCILE;\n      isAttemptingToRecoverFromReconcilerError = true;\n      commitPendingUpdates(editor);\n      isAttemptingToRecoverFromReconcilerError = false;\n    }\n\n    return;\n  } finally {\n    editor._updating = previouslyUpdating;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  pendingEditorState._readOnly = true;\n\n  {\n    handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n  }\n\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n  const pendingDecorators = editor._pendingDecorators;\n\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  triggerTextContentListeners(editor, currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor);\n  triggerEnqueuedUpdates(editor);\n}\n\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\n\nfunction triggerMutationListeners(editor, currentEditorState, pendingEditorState, mutatedNodes) {\n  const listeners = editor._listeners.mutation;\n  listeners.forEach((klass, listener) => {\n    const mutatedNodesByType = mutatedNodes.get(klass);\n\n    if (mutatedNodesByType === undefined) {\n      return;\n    }\n\n    listener(mutatedNodesByType);\n  });\n}\n\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, // $FlowFixMe: needs refining\n...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n\n    for (let i = 0; i < listeners.length; i++) {\n      listeners[i](...payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n\n  const editors = getEditorsToPropagate(editor);\n\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n\n      if (listenerInPriorityOrder !== undefined) {\n        const listeners = listenerInPriorityOrder[i];\n\n        if (listeners !== undefined) {\n          for (const listener of listeners) {\n            // $FlowFixMe[missing-type-arg]\n            if (listener(payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n\n  if (queuedUpdates.length !== 0) {\n    const [updateFn, options] = queuedUpdates.shift();\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\nfunction triggerDeferredUpdateCallbacks(editor) {\n  const deferred = editor._deferred;\n  editor._deferred = [];\n\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\n\nfunction processNestedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = false; // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n\n  while (queuedUpdates.length !== 0) {\n    const [nextUpdateFn, options] = queuedUpdates.shift();\n    let onUpdate;\n    let tag;\n\n    if (options !== undefined) {\n      onUpdate = options.onUpdate;\n      tag = options.tag;\n\n      if (options.skipTransforms) {\n        skipTransforms = true;\n      }\n\n      if (onUpdate) {\n        editor._deferred.push(onUpdate);\n      }\n\n      if (tag) {\n        editor._updateTags.add(tag);\n      }\n    }\n\n    nextUpdateFn();\n  }\n\n  return skipTransforms;\n}\n\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n\n    skipTransforms = options.skipTransforms;\n  }\n\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n\n  if (pendingEditorState === null) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(currentEditorState);\n    editorStateWasCloned = true;\n  }\n\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n\n  try {\n    if (editorStateWasCloned) {\n      pendingEditorState._selection = internalCreateSelection(editor);\n    }\n\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor);\n    applySelectionTransforms(pendingEditorState, editor);\n\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n\n    const endingCompositionKey = editor._compositionKey;\n\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n\n    const pendingSelection = pendingEditorState._selection;\n\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    editor._onError(error); // Restore existing editor state to the DOM\n\n\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n\n    editor._dirtyElements.clear();\n\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\n\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\n\nfunction initTextEntryListener() {\n  if (lastTextEntryTimeStamp === 0) {\n    window.addEventListener('textInput', updateTimeStamp, true);\n  }\n}\n\nfunction isManagedLineBreak(dom, target, editor) {\n  return (// $FlowFixMe: internal field\n    target.__lexicalLineBreak === dom || // $FlowFixMe: internal field\n    dom['__lexicalKey_' + editor._key] !== undefined\n  );\n}\n\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\n\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection();\n  let anchorOffset = null;\n  let focusOffset = null;\n\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n\n  const text = target.nodeValue;\n  $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n}\n\nfunction $flushMutations(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n\n  try {\n    updateEditor(editor, () => {\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement(); // We use the current edtior state, as that reflects what is\n      // actually \"on screen\".\n\n      const currentEditorState = editor._editorState;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n\n        if ($isDecoratorNode(targetNode)) {\n          continue;\n        }\n\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && targetDOM.nodeType === DOM_TEXT_TYPE && $isTextNode(targetNode) && targetNode.isAttached()) {\n            handleTextMutation( // $FlowFixMe: nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true; // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n\n          const addedDOMs = mutation.addedNodes;\n\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor)) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      } // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n\n\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.__children;\n            let currentDOM = targetDOM.firstChild;\n\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n\n              if (correctDOM === null) {\n                continue;\n              }\n\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      } // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n\n\n      const records = observer.takeRecords(); // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        } // Clear any of those removal mutations\n\n\n        observer.takeRecords();\n      }\n\n      const selection = $getSelection() || getLastSelection(editor);\n\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n\n        if (IS_FIREFOX && isFirefoxClipboardEvents()) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener();\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nclass Point {\n  constructor(key, offset, type) {\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n\n    if ($isElementNode(aNode)) {\n      aNode = aNode.getDescendantByIndex(aOffset);\n    }\n\n    if ($isElementNode(bNode)) {\n      bNode = bNode.getDescendantByIndex(bOffset);\n    }\n\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n\n    return aNode.isBefore(bNode);\n  }\n\n  getCharacterOffset() {\n    return this.type === 'text' ? this.offset : 0;\n  }\n\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n\n    return node;\n  }\n\n  set(key, offset, type) {\n    const selection = $getSelection();\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n\n      if (selection !== null && (selection.anchor === this || selection.focus === this)) {\n        selection.dirty = true;\n      }\n    }\n  }\n\n}\n\nfunction $createPoint(key, offset, type) {\n  // $FlowFixMe: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\n\nfunction selectPointOnNode(point, node) {\n  const key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  }\n\n  point.set(key, offset, type);\n}\n\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else if ($isTextNode(node)) {\n    selectPointOnNode(point, node);\n  }\n}\n\nfunction $transferStartingElementPointToTextPoint(start, end, format) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  } // Transfer the element point to a text point.\n\n\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n\n  start.set(textNode.__key, 0, 'text');\n}\n\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key; // $FlowFixMe: internal utility function\n\n  point.offset = offset; // $FlowFixMe: internal utility function\n\n  point.type = type;\n}\n\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n  }\n\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n\n  add(key) {\n    this.dirty = true;\n\n    this._nodes.add(key);\n  }\n\n  delete(key) {\n    this.dirty = true;\n\n    this._nodes.delete(key);\n  }\n\n  clear() {\n    this.dirty = true;\n\n    this._nodes.clear();\n  }\n\n  has(key) {\n    return this._nodes.has(key);\n  }\n\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  getNodes() {\n    const objects = this._nodes;\n    const nodes = [];\n\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass GridSelection {\n  constructor(gridKey, anchorCellKey, focusCellKey) {\n    this.gridKey = gridKey;\n    this.anchorCellKey = anchorCellKey;\n    this.anchor = $createPoint(anchorCellKey, 0, 'element');\n    this.focusCellKey = focusCellKey;\n    this.focus = $createPoint(focusCellKey, 0, 'element');\n    this.dirty = false;\n  }\n\n  is(selection) {\n    if (!$isGridSelection(selection)) {\n      return false;\n    }\n\n    return this.gridKey === selection.gridKey && this.anchorCellKey === selection.anchorCellKey && this.focusCellKey === selection.focusCellKey;\n  }\n\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchorCellKey = anchorCellKey;\n    this.focusCellKey = focusCellKey;\n  }\n\n  clone() {\n    return new GridSelection(this.gridKey, this.anchorCellKey, this.focusCellKey);\n  }\n\n  isCollapsed() {\n    return false;\n  }\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchorCellKey);\n\n    if (!anchorCellNode) {\n      throw Error(`getNodes: expected to find AnchorNode`);\n    }\n\n    const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();\n    const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();\n    const focusCellNode = $getNodeByKey(this.focusCellKey);\n\n    if (!focusCellNode) {\n      throw Error(`getNodes: expected to find FocusNode`);\n    }\n\n    const focusCellNodeIndex = focusCellNode.getIndexWithinParent();\n    const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();\n    const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);\n    const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);\n    const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);\n    const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n\n  getNodes() {\n    const nodes = new Set();\n    const {\n      fromX,\n      fromY,\n      toX,\n      toY\n    } = this.getShape();\n    const gridNode = $getNodeByKey(this.gridKey);\n\n    if (!$isGridNode(gridNode)) {\n      {\n        throw Error(`getNodes: expected to find GridNode`);\n      }\n    }\n\n    nodes.add(gridNode);\n    const gridRowNodes = gridNode.getChildren();\n\n    for (let r = fromY; r <= toY; r++) {\n      const gridRowNode = gridRowNodes[r];\n      nodes.add(gridRowNode);\n\n      if (!$isGridRowNode(gridRowNode)) {\n        {\n          throw Error(`getNodes: expected to find GridRowNode`);\n        }\n      }\n\n      const gridCellNodes = gridRowNode.getChildren();\n\n      for (let c = fromX; c <= toX; c++) {\n        const gridCellNode = gridCellNodes[c];\n\n        if (!$isGridCellNode(gridCellNode)) {\n          {\n            throw Error(`getNodes: expected to find GridCellNode`);\n          }\n        }\n\n        nodes.add(gridCellNode);\n        const children = gridCellNode.getChildren();\n\n        while (children.length > 0) {\n          const child = children.shift();\n          nodes.add(child);\n\n          if ($isElementNode(child)) {\n            children.unshift(...child.getChildren());\n          }\n        }\n      }\n    }\n\n    return Array.from(nodes);\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction $isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n  }\n\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format;\n  }\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  getNodes() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = anchor.getNode();\n    let lastNode = focus.getNode();\n\n    if ($isElementNode(firstNode)) {\n      firstNode = firstNode.getDescendantByIndex(anchor.offset);\n    }\n\n    if ($isElementNode(lastNode)) {\n      lastNode = lastNode.getDescendantByIndex(focus.offset);\n    }\n\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode)) {\n        return [];\n      }\n\n      return [firstNode];\n    }\n\n    return firstNode.getNodesBetween(lastNode);\n  }\n\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this.dirty = true;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const anchorOffset = anchor.getCharacterOffset();\n    const focusOffset = focus.getCharacterOffset();\n    let textContent = '';\n    let prevWasElement = true;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n\n          if (node === firstNode) {\n            if (node === lastNode) {\n              text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n\n    return textContent;\n  }\n\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n  }\n\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    return new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format);\n  }\n\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  insertRawText(text) {\n    const parts = text.split(/\\r?\\n/);\n\n    if (parts.length === 1) {\n      this.insertText(text);\n    } else {\n      const nodes = [];\n      const length = parts.length;\n\n      for (let i = 0; i < length; i++) {\n        const part = parts[i];\n\n        if (part !== '') {\n          nodes.push($createTextNode(part));\n        }\n\n        if (i !== length - 1) {\n          nodes.push($createLineBreakNode());\n        }\n      }\n\n      this.insertNodes(nodes);\n    }\n  }\n\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format);\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter())) {\n      let nextSibling = firstNode.getNextSibling();\n\n      if (!$isTextNode(nextSibling) || $isTokenOrInert(nextSibling) || nextSibling.isSegmented()) {\n        nextSibling = $createTextNode();\n\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore())) {\n      let prevSibling = firstNode.getPreviousSibling();\n\n      if (!$isTextNode(prevSibling) || $isTokenOrInert(prevSibling) || prevSibling.isSegmented()) {\n        prevSibling = $createTextNode();\n\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n\n      prevSibling.select();\n      firstNode = prevSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    }\n\n    if (selectedNodesLength === 1) {\n      if ($isTokenOrInert(firstNode)) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n\n      const firstNodeFormat = firstNode.getFormat();\n\n      if (startOffset === endOffset && firstNodeFormat !== format) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.select();\n\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode);\n          } // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n\n\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n\n          return;\n        }\n      }\n\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n        // When composing, we need to adjust the anchor offset so that\n        // we correctly replace that right range.\n        this.anchor.offset -= text.length;\n      }\n    } else {\n      const lastIndex = selectedNodesLength - 1;\n      let lastNode = selectedNodes[lastIndex];\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      const lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow(); // Handle mutations to the last node.\n\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !$isTokenOrInert(lastNode) && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n\n          lastNode = lastNode.spliceText(0, endOffset, '');\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          lastNode.remove();\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      } // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n\n\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement); // If the last element is an \"inline\" element, don't move it's text nodes to the first node.\n      // Instead, preserve the \"inline\" element's children and append to the first element.\n\n      if (!lastElement.canBeEmpty() && firstElement !== lastElement) {\n        firstElement.append(lastElement);\n      } else {\n        for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n          const lastNodeChild = lastNodeChildren[i];\n\n          if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n            break;\n          }\n\n          if (lastNodeChild.isAttached()) {\n            if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastNode)) {\n              if (!firstAndLastElementsAreEqual) {\n                firstNode.insertAfter(lastNodeChild);\n              }\n            } else {\n              lastNodeChild.remove();\n            }\n          }\n        }\n\n        if (!firstAndLastElementsAreEqual) {\n          // Check if we have already moved out all the nodes of the\n          // last parent, and if so, traverse the parent tree and mark\n          // them all as being able to deleted too.\n          let parent = lastElement;\n          let lastRemovedParent = null;\n\n          while (parent !== null) {\n            const children = parent.getChildren();\n            const childrenLength = children.length;\n\n            if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n              markedNodeKeysForKeep.delete(parent.__key);\n              lastRemovedParent = parent;\n            }\n\n            parent = parent.getParent();\n          }\n        }\n      } // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n\n\n      if (!$isTokenOrInert(firstNode)) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      } // Remove all selected nodes that haven't already been removed.\n\n\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  removeText() {\n    this.insertText('');\n  }\n\n  formatText(formatType) {\n    // TODO I wonder if this methods use selection.extract() instead?\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const focusOffset = focus.offset;\n    let firstNextFormat = 0;\n\n    for (let i = 0; i < selectedNodes.length; i++) {\n      const selectedNode = selectedNodes[i];\n\n      if ($isTextNode(selectedNode)) {\n        firstNextFormat = selectedNode.getFormatFlags(formatType, null);\n        break;\n      }\n    }\n\n    let anchorOffset = anchor.offset;\n    let startOffset;\n    let endOffset;\n    const isBefore = anchor.isBefore(focus);\n    startOffset = isBefore ? anchorOffset : focusOffset;\n    endOffset = isBefore ? focusOffset : anchorOffset; // This is the case where the user only selected the very end of the\n    // first node so we don't want to include it in the formatting change.\n\n    if (startOffset === firstNode.getTextContentSize()) {\n      const nextSibling = firstNode.getNextSibling();\n\n      if ($isTextNode(nextSibling)) {\n        // we basically make the second node the firstNode, changing offsets accordingly\n        anchorOffset = 0;\n        startOffset = 0;\n        firstNode = nextSibling;\n        firstNextFormat = firstNode.getFormatFlags(formatType, null);\n      }\n    } // This is the case where we only selected a single node\n\n\n    if (firstNode.is(lastNode)) {\n      if ($isTextNode(firstNode)) {\n        if (anchor.type === 'element' && focus.type === 'element') {\n          firstNode.setFormat(firstNextFormat);\n          firstNode.select(startOffset, endOffset);\n          this.format = firstNextFormat;\n          return;\n        }\n\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n        if (startOffset === endOffset) {\n          return;\n        } // The entire node is selected, so just format it\n\n\n        if (startOffset === 0 && endOffset === firstNodeTextLength) {\n          firstNode.setFormat(firstNextFormat);\n          firstNode.select(startOffset, endOffset);\n        } else {\n          // ndoe is partially selected, so split it into two nodes\n          // adnd style the selected one.\n          const splitNodes = firstNode.splitText(startOffset, endOffset);\n          const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n          replacement.setFormat(firstNextFormat);\n          replacement.select(0, endOffset - startOffset);\n        }\n\n        this.format = firstNextFormat;\n      } // multiple nodes selected.\n\n    } else {\n      if ($isTextNode(firstNode)) {\n        if (startOffset !== 0) {\n          // the entire first node isn't selected, so split it\n          [, firstNode] = firstNode.splitText(startOffset);\n          startOffset = 0;\n        }\n\n        firstNode.setFormat(firstNextFormat);\n      }\n\n      let lastNextFormat = firstNextFormat;\n\n      if ($isTextNode(lastNode)) {\n        lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n        const lastNodeText = lastNode.getTextContent();\n        const lastNodeTextLength = lastNodeText.length; // if the offset is 0, it means no actual characters are selected,\n        // so we skip formatting the last node altogether.\n\n        if (endOffset !== 0) {\n          // if the entire last node isn't selected, split it\n          if (endOffset !== lastNodeTextLength) {\n            [lastNode] = lastNode.splitText(endOffset);\n          }\n\n          lastNode.setFormat(lastNextFormat);\n        }\n      } // deal with all the nodes in between\n\n\n      for (let i = 1; i < lastIndex; i++) {\n        const selectedNode = selectedNodes[i];\n        const selectedNodeKey = selectedNode.__key;\n\n        if ($isTextNode(selectedNode) && selectedNodeKey !== firstNode.__key && selectedNodeKey !== lastNode.__key && !selectedNode.isToken()) {\n          const selectedNextFormat = selectedNode.getFormatFlags(formatType, lastNextFormat);\n          selectedNode.setFormat(selectedNextFormat);\n        }\n      }\n    }\n  }\n\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n\n    const siblings = []; // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootNode(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if ($isTokenOrInert(anchorNode)) {\n        // Do nothing if we're inside an immutable/inert node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNodeInserted = null; // Time to insert the nodes!\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node)) {\n        // -----\n        // Heuristics for the replacment or merging of elements\n        // -----\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          } // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n\n          const firstDescendant = node.getFirstDescendant();\n\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n\n            const children = element.getChildren();\n            const childrenLength = children.length;\n\n            if ($isElementNode(target)) {\n              for (let s = 0; s < childrenLength; s++) {\n                lastNodeInserted = children[s];\n                target.append(lastNodeInserted);\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                lastNodeInserted = children[s];\n                target.insertAfter(lastNodeInserted);\n              }\n\n              target = target.getParentOrThrow();\n            }\n\n            element.remove();\n            didReplaceOrMerge = true;\n\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isDecoratorNode(node) && $isRootNode(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n\n      didReplaceOrMerge = false;\n\n      if ($isElementNode(target)) {\n        lastNodeInserted = node;\n\n        if ($isDecoratorNode(node) && node.isTopLevel()) {\n          target = target.insertAfter(node);\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n\n            target = node;\n          } else {\n            target = target.insertAfter(node);\n          }\n        }\n      } else if (!$isElementNode(node) || $isDecoratorNode(target) && target.isTopLevel()) {\n        lastNodeInserted = node;\n        target = target.insertAfter(node);\n      } else {\n        target = node.getParentOrThrow(); // Re-try again with the target being the parent\n\n        i--;\n        continue;\n      }\n    }\n\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNodeInserted) ? lastNodeInserted : target.getLastDescendant();\n\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          lastChild.select();\n        } else {\n          lastChild.selectNext();\n        }\n      }\n\n      if (siblings.length !== 0) {\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n\n          if ($isElementNode(target) && !$isElementNode(sibling)) {\n            target.append(sibling);\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          } // Check if the prev parent is empty, as it might need\n          // removing.\n\n\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n\n    return true;\n  }\n\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n\n        if (anchorOffset !== textContentLength) {\n          nodesToMove = anchorNode.getNextSiblings().reverse();\n\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n\n      if ($isRootNode(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n\n        if (child !== null) {\n          child.insertBefore(paragraph);\n        } else {\n          currentElement.append(paragraph);\n        }\n\n        return;\n      }\n\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n\n    const nodesToMoveLength = nodesToMove.length;\n\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      currentElement.getParentOrThrow().insertBefore($createParagraphNode());\n      return;\n    }\n\n    const newElement = currentElement.insertNewAfter(this);\n\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow(); // For inline elements, we append the siblings to the parent.\n\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n\n          firstChild = nodeToMove;\n        }\n      }\n\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const anchorOffset = anchor.getCharacterOffset();\n    const focusOffset = focus.getCharacterOffset();\n\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode)) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n\n      return [firstNode];\n    }\n\n    const isBefore = anchor.isBefore(focus);\n\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n\n    return selectedNodes;\n  }\n\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move'; // Handle the selection movement around decorators.\n\n    const possibleNode = $getDecoratorNode(focus, isBackward);\n\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n\n          if (!isBackward) {\n            offset++;\n          }\n        }\n\n        focus.set(elementKey, offset, 'element');\n\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n\n        return;\n      }\n    }\n\n    const domSelection = getDOMSelection(); // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n\n    $moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity); // Guard against no ranges\n\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0); // Apply the DOM selection to our Lexical selection.\n      // $FlowFixMe[incompatible-call]\n\n      this.applyDOMRange(range); // Because a range works on start and end, we might need to flip\n      // the anchor and focus points to match what the DOM has, not what\n      // the range has specifically.\n\n      if (!collapse && (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset)) {\n        $swapPoints(this);\n      }\n    }\n  }\n\n  deleteCharacter(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n\n      if (!isBackward && ( // Delete forward handle case\n      anchor.type === 'element' && // $FlowFixMe: always an element node\n      anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const nextSibling = anchorNode.getNextSibling() || anchorNode.getParentOrThrow().getNextSibling();\n\n        if ($isElementNode(nextSibling) && !nextSibling.canExtractContents()) {\n          return;\n        }\n      }\n\n      this.modify('extend', isBackward, 'character');\n\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n\n    this.removeText();\n  }\n\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'lineboundary');\n    }\n\n    this.removeText();\n  }\n\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n\n    this.removeText();\n  }\n\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\n\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n}\n\nfunction $moveNativeSelection(domSelection, alter, direction, granularity) {\n  // $FlowFixMe[prop-missing]\n  domSelection.modify(alter, direction, granularity);\n}\n\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\n\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/\\s/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n\n      break;\n    }\n  }\n\n  const nextTextContent = split.join(' ');\n\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\n\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\n\nfunction internalResolveSelectionPoint(dom, offset, lastPoint) {\n  let resolvedOffset = offset;\n  let resolvedNode; // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false; // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length; // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n\n    const childDOM = childNodes[resolvedOffset];\n    resolvedNode = getNodeFromDOM(childDOM);\n\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom); // Ensure resolvedElement is actually a element.\n\n      if (resolvedElement === null) {\n        return null;\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = child.getParentOrThrow();\n          }\n        }\n\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent(); // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\n\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null);\n\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null);\n\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n\n  if (resolvedAnchorPoint.type === 'text' && resolvedFocusPoint.type === 'text') {\n    const resolvedAnchorNode = resolvedAnchorPoint.getNode();\n    const resolvedFocusNode = resolvedFocusPoint.getNode(); // Handle normalization of selection when it is at the boundaries.\n\n    const textContentSize = resolvedAnchorNode.getTextContentSize();\n    const resolvedAnchorOffset = resolvedAnchorPoint.offset;\n    const resolvedFocusOffset = resolvedFocusPoint.offset;\n\n    if (resolvedAnchorNode === resolvedFocusNode && resolvedAnchorOffset === resolvedFocusOffset) {\n      if (anchorOffset === 0) {\n        const prevSibling = resolvedAnchorNode.getPreviousSibling();\n\n        if ($isTextNode(prevSibling) && !prevSibling.isInert()) {\n          const offset = prevSibling.getTextContentSize();\n          const key = prevSibling.__key;\n          resolvedAnchorPoint.key = key;\n          resolvedFocusPoint.key = key;\n          resolvedAnchorPoint.offset = offset;\n          resolvedFocusPoint.offset = offset;\n        }\n      }\n    } else {\n      if (resolvedAnchorOffset === textContentSize) {\n        const nextSibling = resolvedAnchorNode.getNextSibling();\n\n        if ($isTextNode(nextSibling) && !nextSibling.isInert()) {\n          resolvedAnchorPoint.key = nextSibling.__key;\n          resolvedAnchorPoint.offset = 0;\n        }\n      }\n    }\n\n    if (editor.isComposing() && editor._compositionKey !== resolvedAnchorPoint.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(resolvedAnchorPoint, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(resolvedFocusPoint, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n} // This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0);\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createEmptyRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0);\n}\nfunction $createEmptyObjectSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $createEmptyGridSelection() {\n  return new GridSelection('root', 'root', 'root');\n}\n\nfunction getActiveEventType() {\n  const event = window.event;\n  return event && event.type;\n}\n\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection();\n\n  if ($isNodeSelection(lastSelection) || $isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\n\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n  const eventType = getActiveEventType();\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && window.event.detail === 3 || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  } else {\n    return lastSelection.clone();\n  } // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n\n\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format);\n}\n\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction internalCreateSelectionFromParse(parsedSelection) {\n  if (parsedSelection !== null) {\n    if (parsedSelection.type === 'range') {\n      return new RangeSelection($createPoint(parsedSelection.anchor.key, parsedSelection.anchor.offset, parsedSelection.anchor.type), $createPoint(parsedSelection.focus.key, parsedSelection.focus.offset, parsedSelection.focus.type), 0);\n    } else if (parsedSelection.type === 'node') {\n      return new NodeSelection(new Set(parsedSelection.nodes));\n    } else if (parsedSelection.type === 'grid') {\n      return new GridSelection(parsedSelection.gridKey, parsedSelection.anchorCellKey, parsedSelection.focusCellKey);\n    }\n  }\n\n  return null;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n\n  const parentKey = parentNode.__key; // Single node. We shift selection but never redimension it\n\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n\n    if (nodeOffset <= selectionOffset) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element'); // The new selection might point to text nodes, try to resolve them\n\n      $updateSelectionResolveTextNodes(selection);\n    }\n\n    return;\n  } // Multiple nodes selected. We shift or redimension selection\n\n\n  const isBackward = selection.isBackward();\n  const firstPoint = isBackward ? focus : anchor;\n  const firstPointNode = firstPoint.getNode();\n  const lastPoint = isBackward ? anchor : focus;\n  const lastPointNode = lastPoint.getNode();\n\n  if (parentNode.is(firstPointNode)) {\n    const firstPointOffset = firstPoint.offset;\n\n    if (nodeOffset <= firstPointOffset) {\n      firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n    }\n  }\n\n  if (parentNode.is(lastPointNode)) {\n    const lastPointOffset = lastPoint.offset;\n\n    if (nodeOffset <= lastPointOffset) {\n      lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n    }\n  } // The new selection might point to text nodes, try to resolve them\n\n\n  $updateSelectionResolveTextNodes(selection);\n}\n\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n\n    return;\n  }\n\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\n\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction removeNode(nodeToRemove, restoreSelection) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n\n  if (parent === null) {\n    return;\n  }\n\n  const selection = $getSelection();\n  let selectionMoved = false;\n\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  }\n\n  const writableParent = parent.getWritable();\n  const parentChildren = writableParent.__children;\n  const index = parentChildren.indexOf(key);\n\n  if (index === -1) {\n    {\n      throw Error(`Node is not a child of its parent`);\n    }\n  }\n\n  internalMarkSiblingsAsDirty(nodeToRemove);\n  parentChildren.splice(index, 1);\n  const writableNodeToRemove = nodeToRemove.getWritable();\n  writableNodeToRemove.__parent = null;\n\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  }\n\n  if (parent !== null && !$isRootNode(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n\n  if (parent !== null && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n\n  if (node === null) {\n    {\n      throw Error(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n\n  return node;\n}\nclass LexicalNode {\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  static clone(data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    $setNodeKey(this, key); // Ensure custom nodes implement required methods.\n\n    {\n      const proto = Object.getPrototypeOf(this);\n      ['getType', 'clone'].forEach(method => {\n        if (!proto.constructor.hasOwnProperty(method)) {\n          console.warn(`${this.constructor.name} must implement static \"${method}\" method`);\n        }\n      });\n\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  } // Getters and Traversers\n\n\n  getType() {\n    return this.__type;\n  }\n\n  isAttached() {\n    let nodeKey = this.__key;\n\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n\n      const node = $getNodeByKey(nodeKey);\n\n      if (node === null) {\n        break;\n      }\n\n      nodeKey = node.__parent;\n    }\n\n    return false;\n  }\n\n  isSelected() {\n    const selection = $getSelection();\n\n    if (selection == null) {\n      return false;\n    }\n\n    const selectedNodeKeys = new Set(selection.getNodes().map(n => n.__key));\n    const isSelected = selectedNodeKeys.has(this.__key);\n\n    if ($isTextNode(this)) {\n      return isSelected;\n    } // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n\n\n    if ($isRangeSelection(selection) && selection.anchor.type === 'element' && selection.focus.type === 'element' && selection.anchor.key === selection.focus.key && selection.anchor.offset === selection.focus.offset) {\n      return false;\n    }\n\n    return isSelected;\n  }\n\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  getIndexWithinParent() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return -1;\n    }\n\n    const children = parent.__children;\n    return children.indexOf(this.__key);\n  }\n\n  getParent() {\n    const parent = this.getLatest().__parent;\n\n    if (parent === null) {\n      return null;\n    }\n\n    return $getNodeByKey(parent);\n  }\n\n  getParentOrThrow() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n\n    return parent;\n  }\n\n  getTopLevelElement() {\n    let node = this;\n\n    while (node !== null) {\n      const parent = node.getParent();\n\n      if ($isRootNode(parent) && $isElementNode(node)) {\n        return node;\n      }\n\n      node = parent;\n    }\n\n    return null;\n  }\n\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n\n    return parent;\n  }\n\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n\n  getPreviousSibling() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return null;\n    }\n\n    const children = parent.__children;\n    const index = children.indexOf(this.__key);\n\n    if (index <= 0) {\n      return null;\n    }\n\n    return $getNodeByKey(children[index - 1]);\n  }\n\n  getPreviousSiblings() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return [];\n    }\n\n    const children = parent.__children;\n    const index = children.indexOf(this.__key);\n    return children.slice(0, index).map(childKey => $getNodeByKeyOrThrow(childKey));\n  }\n\n  getNextSibling() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return null;\n    }\n\n    const children = parent.__children;\n    const childrenLength = children.length;\n    const index = children.indexOf(this.__key);\n\n    if (index >= childrenLength - 1) {\n      return null;\n    }\n\n    return $getNodeByKey(children[index + 1]);\n  }\n\n  getNextSiblings() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return [];\n    }\n\n    const children = parent.__children;\n    const index = children.indexOf(this.__key);\n    return children.slice(index + 1).map(childKey => $getNodeByKeyOrThrow(childKey));\n  }\n\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n\n    const aLength = a.length;\n    const bLength = b.length;\n\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n\n    const bSet = new Set(b);\n\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n\n    return null;\n  }\n\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n\n    return this.__key === object.__key;\n  }\n\n  isBefore(targetNode) {\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexA = parent.__children.indexOf(node.__key);\n        break;\n      }\n\n      node = parent;\n    }\n\n    node = targetNode;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexB = parent.__children.indexOf(node.__key);\n        break;\n      }\n\n      node = parent;\n    }\n\n    return indexA < indexB;\n  }\n\n  isParentOf(targetNode) {\n    const key = this.__key;\n\n    if (key === targetNode.__key) {\n      return false;\n    }\n\n    let node = targetNode;\n\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n\n      node = node.getParent();\n    }\n\n    return false;\n  }\n\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    let dfsAncestor = null;\n\n    while (true) {\n      const key = node.__key;\n\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n\n      if (node === targetNode) {\n        break;\n      }\n\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n\n      if (child !== null) {\n        if (dfsAncestor === null) {\n          dfsAncestor = node;\n        }\n\n        node = child;\n        continue;\n      }\n\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n\n      const parent = node.getParentOrThrow();\n\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n\n      if (parent === targetNode) {\n        break;\n      }\n\n      let parentSibling = null;\n      let ancestor = parent;\n\n      if (parent.is(dfsAncestor)) {\n        dfsAncestor = null;\n      }\n\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n\n        if (ancestor !== null) {\n          if (ancestor.is(dfsAncestor)) {\n            dfsAncestor = null;\n          }\n\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n\n      node = parentSibling;\n    }\n\n    if (!isBefore) {\n      nodes.reverse();\n    }\n\n    return nodes;\n  }\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  } // TODO remove this and move to TextNode\n\n\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n\n    if (latest === null) {\n      {\n        throw Error(`getLatest: node not found`);\n      }\n    }\n\n    return latest;\n  } // $FlowFixMe this is LexicalNode\n\n\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key; // Ensure we get the latest node from pending state\n\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n\n    const constructor = latestNode.constructor;\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__children = Array.from(latestNode.__children);\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode); // Update reference in node map\n\n    nodeMap.set(key, mutableNode); // $FlowFixMe this is LexicalNode\n\n    return mutableNode;\n  } // TODO remove this completely\n\n\n  getTextContent(includeInert, includeDirectionless) {\n    return '';\n  } // TODO remove this completely\n\n\n  getTextContentSize(includeInert, includeDirectionless) {\n    return this.getTextContent(includeInert, includeDirectionless).length;\n  } // View\n  // $FlowFixMe: Revise typings for EditorContext\n\n\n  createDOM(config, editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  } // $FlowFixMe: Revise typings for EditorContext\n\n\n  updateDOM( // $FlowFixMe: TODO\n  prevNode, dom, config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  } // $FlowFixMe: Revise typings for EditorContext\n\n\n  exportDOM(editor) {\n    if ($isDecoratorNode(this)) {\n      const element = editor.getElementByKey(this.getKey());\n      return {\n        element: element ? element.cloneNode() : null\n      };\n    }\n\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  static importDOM() {\n    return null;\n  } // Setters and mutators\n\n\n  remove() {\n    errorOnReadOnly();\n    removeNode(this, true);\n  }\n\n  replace(replaceWith) {\n    errorOnReadOnly();\n    const toReplaceKey = this.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    removeFromParent(writableReplaceWith);\n    const newParent = this.getParentOrThrow();\n    const writableParent = newParent.getWritable();\n    const children = writableParent.__children;\n    const index = children.indexOf(this.__key);\n    const newKey = writableReplaceWith.__key;\n\n    if (index === -1) {\n      {\n        throw Error(`Node is not a child of its parent`);\n      }\n    }\n\n    children.splice(index, 0, newKey);\n    writableReplaceWith.__parent = newParent.__key;\n    removeNode(this, false);\n    internalMarkSiblingsAsDirty(writableReplaceWith);\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(newKey);\n    }\n\n    return writableReplaceWith;\n  }\n\n  insertAfter(nodeToInsert) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    const oldIndex = nodeToInsert.getIndexWithinParent();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n\n    if (oldParent !== null) {\n      removeFromParent(writableNodeToInsert);\n\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const children = writableParent.__children;\n    const index = children.indexOf(writableSelf.__key);\n\n    if (index === -1) {\n      {\n        throw Error(`Node is not a child of its parent`);\n      }\n    }\n\n    children.splice(index + 1, 0, insertKey);\n    internalMarkSiblingsAsDirty(writableNodeToInsert);\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n\n    return nodeToInsert;\n  }\n\n  insertBefore(nodeToInsert) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    removeFromParent(writableNodeToInsert);\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const children = writableParent.__children;\n    const index = children.indexOf(writableSelf.__key);\n\n    if (index === -1) {\n      {\n        throw Error(`Node is not a child of its parent`);\n      }\n    }\n\n    children.splice(index, 0, insertKey);\n    internalMarkSiblingsAsDirty(writableNodeToInsert);\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index);\n    }\n\n    return nodeToInsert;\n  }\n\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n\n    if (nextSibling === null) {\n      return parent.select();\n    }\n\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n\n    return nextSibling.select(anchorOffset, focusOffset);\n  } // Proxy to mark something as dirty\n\n\n  markDirty() {\n    this.getWritable();\n  }\n\n}\n\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type); // Common error - split in its own invariant\n\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not previously registered on the editor. You can use register your custom nodes.`);\n    }\n  }\n\n  const editorKlass = registeredNode.klass;\n\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key); // ensure custom nodes implement required methods\n\n    {\n      const proto = Object.getPrototypeOf(this);\n      ['decorate'].forEach(method => {\n        if (!proto.hasOwnProperty(method)) {\n          console.warn(`${this.constructor.name} must implement \"${method}\" method`);\n        }\n      });\n    }\n  }\n\n  decorate(editor) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n\n  isIsolated() {\n    return false;\n  }\n\n  isTopLevel() {\n    return false;\n  }\n\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass ElementNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n    this.__children = [];\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n\n  getChildren() {\n    const self = this.getLatest();\n    const children = self.__children;\n    const childrenNodes = [];\n\n    for (let i = 0; i < children.length; i++) {\n      const childNode = $getNodeByKey(children[i]);\n\n      if (childNode !== null) {\n        childrenNodes.push(childNode);\n      }\n    }\n\n    return childrenNodes;\n  }\n\n  getChildrenKeys() {\n    return this.getLatest().__children;\n  }\n\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__children.length;\n  }\n\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n\n  getAllTextNodes(includeInert) {\n    const textNodes = [];\n    const self = this.getLatest();\n    const children = self.__children;\n\n    for (let i = 0; i < children.length; i++) {\n      const childNode = $getNodeByKey(children[i]);\n\n      if ($isTextNode(childNode) && (includeInert || !childNode.isInert())) {\n        textNodes.push(childNode);\n      } else if ($isElementNode(childNode)) {\n        const subChildrenNodes = childNode.getAllTextNodes(includeInert);\n        textNodes.push(...subChildrenNodes);\n      }\n    }\n\n    return textNodes;\n  }\n\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getLastDescendant() {\n    let node = this.getLastChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    if (childrenLength === 0) {\n      return this;\n    } // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n\n\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode;\n    }\n\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode;\n  }\n\n  getFirstChild() {\n    const self = this.getLatest();\n    const children = self.__children;\n    const childrenLength = children.length;\n\n    if (childrenLength === 0) {\n      return null;\n    }\n\n    return $getNodeByKey(children[0]);\n  }\n\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n\n    return firstChild;\n  }\n\n  getLastChild() {\n    const self = this.getLatest();\n    const children = self.__children;\n    const childrenLength = children.length;\n\n    if (childrenLength === 0) {\n      return null;\n    }\n\n    return $getNodeByKey(children[childrenLength - 1]);\n  }\n\n  getChildAtIndex(index) {\n    const self = this.getLatest();\n    const children = self.__children;\n    const key = children[index];\n\n    if (key === undefined) {\n      return null;\n    }\n\n    return $getNodeByKey(key);\n  }\n\n  getTextContent(includeInert, includeDirectionless) {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent(includeInert, includeDirectionless);\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += '\\n\\n';\n      }\n    }\n\n    return textContent;\n  }\n\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n\n  hasFormat(type) {\n    const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  } // Mutators\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n\n    const key = this.__key;\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n\n    return selection;\n  }\n\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    } // Decorator or LineBreak\n\n\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n\n    return this.select(0, 0);\n  }\n\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    } // Decorator or LineBreak\n\n\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n\n    return this.select();\n  }\n\n  clear() {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n\n  append(...nodesToAppend) {\n    errorOnReadOnly();\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n\n  setDirection(direction) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n\n  setFormat(type) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__format = ELEMENT_TYPE_TO_FORMAT[type];\n    return this;\n  }\n\n  setIndent(indentLevel) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n\n  splice(start, deleteCount, nodesToInsert) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const writableSelfChildren = writableSelf.__children;\n    const nodesToInsertLength = nodesToInsert.length;\n    const nodesToInsertKeys = []; // Remove nodes to insert from their previous parent\n\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      const writableNodeToInsert = nodeToInsert.getWritable();\n\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attemtping to append self`);\n        }\n      }\n\n      removeFromParent(writableNodeToInsert); // Set child parent to self\n\n      writableNodeToInsert.__parent = writableSelfKey;\n      const newKey = writableNodeToInsert.__key;\n      nodesToInsertKeys.push(newKey);\n    } // Mark range edges siblings as dirty\n\n\n    const nodeBeforeRange = this.getChildAtIndex(start - 1);\n\n    if (nodeBeforeRange) {\n      internalMarkNodeAsDirty(nodeBeforeRange);\n    }\n\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n\n    if (nodeAfterRange) {\n      internalMarkNodeAsDirty(nodeAfterRange);\n    } // Remove defined range of children\n\n\n    let nodesToRemoveKeys; // Using faster push when only appending nodes\n\n    if (start === writableSelfChildren.length) {\n      writableSelfChildren.push(...nodesToInsertKeys);\n      nodesToRemoveKeys = [];\n    } else {\n      nodesToRemoveKeys = writableSelfChildren.splice(start, deleteCount, ...nodesToInsertKeys);\n    } // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n\n\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n\n        const isPointRemoved = point => {\n          let node = point.getNode();\n\n          while (node) {\n            const nodeKey = node.__key;\n\n            if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n              return true;\n            }\n\n            node = node.getParent();\n          }\n\n          return false;\n        };\n\n        const {\n          anchor,\n          focus\n        } = selection;\n\n        if (isPointRemoved(anchor)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n\n        if (isPointRemoved(focus)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        } // Unlink removed nodes from current parent\n\n\n        const nodesToRemoveKeysLength = nodesToRemoveKeys.length;\n\n        for (let i = 0; i < nodesToRemoveKeysLength; i++) {\n          const nodeToRemove = $getNodeByKey(nodesToRemoveKeys[i]);\n\n          if (nodeToRemove != null) {\n            const writableNodeToRemove = nodeToRemove.getWritable();\n            writableNodeToRemove.__parent = null;\n          }\n        } // Cleanup if node can't be empty\n\n\n        if (writableSelfChildren.length === 0 && !this.canBeEmpty() && !$isRootNode(this)) {\n          this.remove();\n        }\n      }\n    }\n\n    return writableSelf;\n  } // These are intended to be extends for specific element heuristics.\n\n\n  insertNewAfter(selection) {\n    return null;\n  }\n\n  canInsertTab() {\n    return false;\n  }\n\n  collapseAtStart(selection) {\n    return false;\n  }\n\n  excludeFromCopy() {\n    return false;\n  }\n\n  canExtractContents() {\n    return true;\n  }\n\n  canReplaceWith(replacement) {\n    return true;\n  }\n\n  canInsertAfter(node) {\n    return true;\n  }\n\n  canBeEmpty() {\n    return true;\n  }\n\n  canInsertTextBefore() {\n    return true;\n  }\n\n  canInsertTextAfter() {\n    return true;\n  }\n\n  isInline() {\n    return false;\n  }\n\n  canMergeWith(node) {\n    return false;\n  }\n\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass RootNode extends ElementNode {\n  static getType() {\n    return 'root';\n  }\n\n  static clone() {\n    return new RootNode();\n  }\n\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n\n  getTextContent(includeInert, includeDirectionless) {\n    const cachedText = this.__cachedText;\n\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null && (!includeInert || includeDirectionless !== false)) {\n        return cachedText;\n      }\n    }\n\n    return super.getTextContent(includeInert, includeDirectionless);\n  }\n\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n\n  insertAfter(node) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  } // View\n\n\n  updateDOM(prevNode, dom) {\n    return false;\n  } // Mutate\n\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n\n    return super.append(...nodesToAppend);\n  }\n\n  toJSON() {\n    return {\n      __children: this.__children,\n      __dir: this.__dir,\n      __format: this.__format,\n      __indent: this.__indent,\n      __key: 'root',\n      __parent: null,\n      __type: 'root'\n    };\n  }\n\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n\n  const pendingSelection = editorState._selection; // Check if we need to update because of changes in selection\n\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n\n  toJSON(space) {\n    const selection = this._selection;\n    return {\n      _nodeMap: Array.from(this._nodeMap.entries()),\n      _selection: $isRangeSelection(selection) ? {\n        anchor: {\n          key: selection.anchor.key,\n          offset: selection.anchor.offset,\n          type: selection.anchor.type\n        },\n        focus: {\n          key: selection.focus.key,\n          offset: selection.focus.offset,\n          type: selection.focus.type\n        },\n        type: 'range'\n      } : $isNodeSelection(selection) ? {\n        nodes: Array.from(selection._nodes),\n        type: 'node'\n      } : $isGridSelection(selection) ? {\n        anchorCellKey: selection.anchorCellKey,\n        focusCellKey: selection.focusCellKey,\n        gridKey: selection.gridKey,\n        type: 'grid'\n      } : null\n    };\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  createDOM() {\n    return document.createElement('br');\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      br: node => ({\n        conversion: convertLineBreakElement,\n        priority: 0\n      })\n    };\n  }\n\n}\n\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\n\nfunction $createLineBreakNode() {\n  return new LineBreakNode();\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n\n  return null;\n}\n\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n\n  return 'span';\n}\n\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList; // Firstly we handle the base theme.\n\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  } // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n\n\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    // $FlowFixMe: expected cast here\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n\n          continue;\n        }\n\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\n\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\n\nfunction setTextContent(nextText, dom, node) {\n  // $FlowFixMe: first node is always text\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing(); // Always add a suffix if we're composing a node\n\n  const suffix = isComposing ? ZERO_WIDTH_CHAR : '';\n  const text = nextText + suffix;\n\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) if (isComposing) {\n      const [index, remove, insert] = diffComposedText(nodeValue, text);\n\n      if (remove !== 0) {\n        firstChild.deleteData(index, remove);\n      }\n\n      firstChild.insertData(index, insert);\n    } else {\n      firstChild.nodeValue = text;\n    }\n  }\n}\n\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme; // Apply theme class names\n\n  const textClassNames = theme.text;\n\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\n\nclass TextNode extends LexicalNode {\n  static getType() {\n    return 'text';\n  }\n\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n\n  isInert() {\n    const self = this.getLatest();\n    return self.__mode === IS_INERT;\n  }\n\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  getTextContent(includeInert, includeDirectionless) {\n    if (!includeInert && this.isInert() || includeDirectionless === false && this.isDirectionless()) {\n      return '';\n    }\n\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  } // View\n  // $FlowFixMe: Revise typings for EditorContext\n\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n\n    return dom;\n  } // $FlowFixMe: Revise typings for EditorContext\n\n\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n\n    if (prevTag !== nextTag) {\n      return true;\n    }\n\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // $FlowFixMe: should always be an element\n      const prevInnerDOM = dom.firstChild;\n\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n\n    let innerDOM = dom;\n\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        // $FlowFixMe: should always be an element\n        innerDOM = dom.firstChild;\n\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme; // Apply theme class names\n\n    const textClassNames = theme.text;\n\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      '#text': node => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: node => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      em: node => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: node => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: node => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: node => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: node => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  } // Mutators\n\n\n  selectionTransform(prevSelection, nextSelection) {}\n\n  setFormat(format) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__format = format;\n    return self;\n  }\n\n  setStyle(style) {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n\n  toggleDirectionless() {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  toggleUnmergeable() {\n    errorOnReadOnly();\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  setMode(type) {\n    errorOnReadOnly();\n    const mode = TEXT_MODE_TO_TYPE[type];\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  setTextContent(text) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    writableSelf.__text = text;\n    return writableSelf;\n  }\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n\n    return selection;\n  }\n\n  spliceText(offset, delCount, newText, moveSelection) {\n    errorOnReadOnly();\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n\n    if (index < 0) {\n      index = handledTextLength + index;\n\n      if (index < 0) {\n        index = 0;\n      }\n    }\n\n    const selection = $getSelection();\n\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    return writableSelf.setTextContent(updatedText);\n  }\n\n  canInsertTextBefore() {\n    return true;\n  }\n\n  canInsertTextAfter() {\n    return true;\n  }\n\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n\n      string += textContent[i];\n    }\n\n    if (string !== '') {\n      parts.push(string);\n    }\n\n    const partsLength = parts.length;\n\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    const parentKey = parent.__key;\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__parent = parentKey;\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    } // Handle selection\n\n\n    const selection = $getSelection(); // Then handle all other parts\n\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n\n      textSize = nextTextSize;\n      sibling.__parent = parentKey;\n      splitNodes.push(sibling);\n    } // Insert the nodes into the parent's children\n\n\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const writableParentChildren = writableParent.__children;\n    const insertionIndex = writableParentChildren.indexOf(key);\n    const splitNodesKeys = splitNodes.map(splitNode => splitNode.__key);\n\n    if (hasReplacedSelf) {\n      writableParentChildren.splice(insertionIndex, 0, ...splitNodesKeys);\n      this.remove();\n    } else {\n      writableParentChildren.splice(insertionIndex, 1, ...splitNodesKeys);\n    }\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n\n    return splitNodes;\n  }\n\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n\n    const newText = isBefore ? target.__text + text : text + target.__text;\n    this.setTextContent(newText);\n    target.remove();\n    return this.getLatest();\n  }\n\n  isTextEntity() {\n    return false;\n  }\n\n}\n\nfunction convertSpanElement(domNode) {\n  // $FlowFixMe[incompatible-type] domNode is a <span> since we matched it by nodeName\n  const span = domNode; // Google Docs uses span tags + font-weight for bold text\n\n  const hasBoldFontWeight = span.style.fontWeight === '700';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction convertBringAttentionToElement(domNode) {\n  // $FlowFixMe[incompatible-type] domNode is a <b> since we matched it by nodeName\n  const b = domNode; // Google Docs wraps all copied HTML in a <b> with font-weight normal\n\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction convertTextDOMNode(domNode) {\n  return {\n    node: $createTextNode(domNode.textContent)\n  };\n}\n\nconst nodeNameToTextFormat = {\n  em: 'italic',\n  i: 'italic',\n  strong: 'bold',\n  u: 'underline'\n};\n\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode)) {\n        lexicalNode.toggleFormat(format);\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction $createTextNode(text = '') {\n  return new TextNode(text);\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  } // View\n\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      if (this.getTextContentSize() === 0) {\n        element.append(document.createElement('br'));\n      }\n    }\n\n    return {\n      element\n    };\n  } // Mutation\n\n\n  insertNewAfter() {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const children = this.getChildren(); // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n\n      const prevSibling = this.getPreviousSibling();\n\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction convertParagraphElement() {\n  return {\n    node: $createParagraphNode()\n  };\n}\n\nfunction $createParagraphNode() {\n  return new ParagraphNode();\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4; // eslint-disable-next-line no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n\n  editor._cloneNotNeeded.clear();\n\n  editor._dirtyLeaves = new Set();\n\n  editor._dirtyElements.clear();\n\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  } // Remove all the DOM nodes from the root element\n\n\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\n\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n\n    if (handledConversions.has(importDOM)) {\n      return;\n    }\n\n    handledConversions.add(importDOM);\n    const map = importDOM();\n\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\n\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const namespace = config.namespace || createUID();\n  const theme = config.theme || {};\n  const context = config.context || {};\n  const parentEditor = config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isReadOnly = config.readOnly || false;\n  const registeredNodes = new Map();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const klass = nodes[i];\n    const type = klass.getType();\n    registeredNodes.set(type, {\n      klass,\n      transforms: new Set()\n    });\n  } // klass: Array<Class<LexicalNode>>\n  // $FlowFixMe: use our declared type instead\n\n\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    // $FlowFixMe: we use our internal type to simpify the generics\n    context,\n    disableEvents,\n    namespace,\n    theme\n  }, onError, initializeConversionCache(registeredNodes), isReadOnly);\n\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n\n  return editor;\n}\nclass LexicalEditor {\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, readOnly) {\n    this._parentEditor = parentEditor; // The root element associated with this editor\n\n    this._rootElement = null; // The current editor state\n\n    this._editorState = editorState; // Handling of drafts and updates\n\n    this._pendingEditorState = null; // Used to help co-ordinate selection and events\n\n    this._compositionKey = null;\n    this._deferred = []; // Used during reconciliation\n\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false; // Listeners\n\n    this._listeners = {\n      decorator: new Set(),\n      mutation: new Map(),\n      readonly: new Set(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    }; // Commands\n\n    this._commands = new Map(); // Editor configuration for theme/context.\n\n    this._config = config; // Mapping of types to their nodes\n\n    this._nodes = nodes; // React node decorators for portals\n\n    this._decorators = {};\n    this._pendingDecorators = null; // Used to optimize reconcilation\n\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set(); // Handling of DOM mutations\n\n    this._observer = null; // Used for identifying owning editors\n\n    this._key = generateRandomKey();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._readOnly = false;\n  }\n\n  isComposing() {\n    return this._compositionKey != null;\n  }\n\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerReadOnlyListener(listener) {\n    const listenerSetOrMap = this._listeners.readonly;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n\n    const commandsMap = this._commands;\n\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n\n    const listenersInPriorityOrder = commandsMap.get(command);\n\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${command} not found in command map`);\n      }\n    }\n\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  registerNodeTransform( // There's no Flow-safe way to preserve the T in Transform<T>, but <T: LexicalNode> in the\n  // declaration below guarantees these are LexicalNodes.\n  klass, listener) {\n    const type = klass.getType();\n\n    const registeredNode = this._nodes.get(type);\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    markAllNodesAsDirty(this, type);\n    return () => {\n      transforms.delete(listener);\n    };\n  }\n\n  hasNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const klass = nodes[i];\n      const type = klass.getType();\n\n      if (!this._nodes.has(type)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  getDecorators() {\n    return this._decorators;\n  }\n\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  getKey() {\n    return this._key;\n  }\n\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n\n    if (nextRootElement !== prevRootElement) {\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n      }\n\n      if (nextRootElement !== null) {\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n\n        this._updateTags.add('history-merge');\n\n        commitPendingUpdates(this); // TODO: remove this flag once we no longer use UEv2 internally\n\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n      }\n\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  getEditorState() {\n    return this._editorState;\n  }\n\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n\n      commitPendingUpdates(this);\n    }\n\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._compositionKey = null;\n\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    commitPendingUpdates(this);\n  }\n\n  parseEditorState(stringifiedEditorState) {\n    const parsedEditorState = JSON.parse(stringifiedEditorState);\n    return parseEditorState(parsedEditorState, this);\n  }\n\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  focus(callbackFn) {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          root.selectEnd();\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n\n          if (callbackFn) {\n            callbackFn();\n          }\n        }\n      });\n    }\n  }\n\n  blur() {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n\n    const domSelection = getDOMSelection();\n\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n\n  isReadOnly() {\n    return this._readOnly;\n  }\n\n  setReadOnly(readOnly) {\n    this._readOnly = readOnly;\n    triggerListeners('readonly', this, true, readOnly);\n  }\n\n  toJSON() {\n    return {\n      editorState: this._editorState\n    };\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst VERSION = '0.2.2';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass GridCellNode extends ElementNode {\n  constructor(colSpan, key) {\n    super(key);\n  }\n\n}\nfunction $isGridCellNode(node) {\n  return node instanceof GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass GridNode extends ElementNode {}\nfunction $isGridNode(node) {\n  return node instanceof GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass GridRowNode extends ElementNode {}\nfunction $isGridRowNode(node) {\n  return node instanceof GridRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction createCommand() {\n  // $FlowFixMe: avoid freezing the object for perf reasons\n  return {};\n}\nconst SELECTION_CHANGE_COMMAND = createCommand();\nconst CLICK_COMMAND = createCommand();\nconst DELETE_CHARACTER_COMMAND = createCommand();\nconst INSERT_LINE_BREAK_COMMAND = createCommand();\nconst INSERT_PARAGRAPH_COMMAND = createCommand();\nconst INSERT_TEXT_COMMAND = createCommand();\nconst PASTE_COMMAND = createCommand();\nconst REMOVE_TEXT_COMMAND = createCommand();\nconst DELETE_WORD_COMMAND = createCommand();\nconst DELETE_LINE_COMMAND = createCommand();\nconst FORMAT_TEXT_COMMAND = createCommand();\nconst UNDO_COMMAND = createCommand();\nconst REDO_COMMAND = createCommand();\nconst KEY_ARROW_RIGHT_COMMAND = createCommand();\nconst KEY_ARROW_LEFT_COMMAND = createCommand();\nconst KEY_ARROW_UP_COMMAND = createCommand();\nconst KEY_ARROW_DOWN_COMMAND = createCommand();\nconst KEY_ENTER_COMMAND = createCommand();\nconst KEY_BACKSPACE_COMMAND = createCommand();\nconst KEY_ESCAPE_COMMAND = createCommand();\nconst KEY_DELETE_COMMAND = createCommand();\nconst KEY_TAB_COMMAND = createCommand();\nconst INDENT_CONTENT_COMMAND = createCommand();\nconst OUTDENT_CONTENT_COMMAND = createCommand();\nconst DROP_COMMAND = createCommand();\nconst FORMAT_ELEMENT_COMMAND = createCommand();\nconst DRAGSTART_COMMAND = createCommand();\nconst COPY_COMMAND = createCommand();\nconst CUT_COMMAND = createCommand();\nconst CLEAR_EDITOR_COMMAND = createCommand();\nconst CLEAR_HISTORY_COMMAND = createCommand();\nconst CAN_REDO_COMMAND = createCommand();\nconst CAN_UNDO_COMMAND = createCommand();\nconst FOCUS_COMMAND = createCommand();\nconst BLUR_COMMAND = createCommand();\n\nexports.$createGridSelection = $createEmptyGridSelection;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeFromParse = $createNodeFromParse;\nexports.$createNodeSelection = $createEmptyObjectSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createEmptyRangeSelection;\nexports.$createTextNode = $createTextNode;\nexports.$getDecoratorNode = $getDecoratorNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isGridCellNode = $isGridCellNode;\nexports.$isGridNode = $isGridNode;\nexports.$isGridRowNode = $isGridRowNode;\nexports.$isGridSelection = $isGridSelection;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.GridCellNode = GridCellNode;\nexports.GridNode = GridNode;\nexports.GridRowNode = GridRowNode;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.INSERT_TEXT_COMMAND = INSERT_TEXT_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.VERSION = VERSION;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/lexical/Lexical.dev.js?");

/***/ }),

/***/ "./node_modules/lexical/Lexical.js":
/*!*****************************************!*\
  !*** ./node_modules/lexical/Lexical.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst Lexical =  true ? __webpack_require__(/*! ./Lexical.dev.js */ \"./node_modules/lexical/Lexical.dev.js\") : 0\nmodule.exports = Lexical;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/lexical/Lexical.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-c.js":
/*!****************************************************!*\
  !*** ./node_modules/prismjs/components/prism-c.js ***!
  \****************************************************/
/***/ (() => {

eval("Prism.languages.c = Prism.languages.extend('clike', {\n\t'comment': {\n\t\tpattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\tgreedy: true\n\t},\n\t'string': {\n\t\t// https://en.cppreference.com/w/c/language/string_literal\n\t\tpattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n\t\tlookbehind: true\n\t},\n\t'keyword': /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n\t'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n\t'number': /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n\t'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t'char': {\n\t\t// https://en.cppreference.com/w/c/language/character_constant\n\t\tpattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n\t\tgreedy: true\n\t}\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t'macro': {\n\t\t// allow for multiline macro definitions\n\t\t// spaces after the # character compile fine with gcc\n\t\tpattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property',\n\t\tinside: {\n\t\t\t'string': [\n\t\t\t\t{\n\t\t\t\t\t// highlight the path of the include statement as a string\n\t\t\t\t\tpattern: /^(#\\s*include\\s*)<[^>]+>/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\tPrism.languages.c['string']\n\t\t\t],\n\t\t\t'char': Prism.languages.c['char'],\n\t\t\t'comment': Prism.languages.c['comment'],\n\t\t\t'macro-name': [\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'function'\n\t\t\t\t}\n\t\t\t],\n\t\t\t// highlight macro directives as keywords\n\t\t\t'directive': {\n\t\t\t\tpattern: /^(#\\s*)[a-z]+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t'directive-hash': /^#/,\n\t\t\t'punctuation': /##|\\\\(?=[\\r\\n])/,\n\t\t\t'expression': {\n\t\t\t\tpattern: /\\S[\\s\\S]*/,\n\t\t\t\tinside: Prism.languages.c\n\t\t\t}\n\t\t}\n\t}\n});\n\nPrism.languages.insertBefore('c', 'function', {\n\t// highlight predefined macros as constants\n\t'constant': /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\n\ndelete Prism.languages.c['boolean'];\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-c.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-clike.js":
/*!********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-clike.js ***!
  \********************************************************/
/***/ (() => {

eval("Prism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-clike.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-core.js":
/*!*******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-core.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/// <reference lib=\"WebWorker\"/>\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n\n\t// Private helper vars\n\tvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tmanual: _self.Prism && _self.Prism.manual,\n\t\t/**\n\t\t * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n\t\t * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n\t\t * own worker, you don't want it to do this.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not add its own listeners to the worker.\n\t\t *\n\t\t * You obviously have to change this value before Prism executes. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.disableWorkerMessageHandler = true;\n\t\t * // Load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar m = lang.exec(element.className);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\treturn m[1].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetLanguage: function (element, language) {\n\t\t\t\t// remove all `language-xxxx` classes\n\t\t\t\t// (this might leave behind a leading space)\n\t\t\t\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t\t\t\t// add the new `language-xxxx` class\n\t\t\t\t// (using `classList` will automatically clean up spaces for us)\n\t\t\t\telement.classList.add('language-' + language);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */\n\t\t\tcurrentScript: function () {\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {\n\t\t\t\t\treturn /** @type {any} */ (document.currentScript);\n\t\t\t\t}\n\n\t\t\t\t// IE11 workaround\n\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace\n\t\t\t\t// this will not work for inline scripts\n\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.\n\t\t\t\t\t// A stack will look like this:\n\t\t\t\t\t//\n\t\t\t\t\t// Error\n\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)\n\n\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\t\t\t\tfor (var i in scripts) {\n\t\t\t\t\t\t\tif (scripts[i].src == src) {\n\t\t\t\t\t\t\t\treturn scripts[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\t\t/**\n\t\t * This is the most high-level function in Prisms API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAll: function (async, callback) {\n\t\t\t_.highlightAllUnder(document, async, callback);\n\t\t},\n\n\t\t/**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAllUnder: function (container, async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tcontainer: container,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlightall', env);\n\n\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n\n\t\t\t_.hooks.run('before-all-elements-highlight', env);\n\n\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language = _.util.getLanguage(element);\n\t\t\tvar grammar = _.languages[language];\n\n\t\t\t// Set language on the element, if not present\n\t\t\t_.util.setLanguage(element, language);\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tvar parent = element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\t\t_.util.setLanguage(parent, language);\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\tfunction insertHighlightedCode(highlightedCode) {\n\t\t\t\tenv.highlightedCode = highlightedCode;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t}\n\n\t\t\t_.hooks.run('before-sanity-check', env);\n\n\t\t\t// plugins may change/add the parent/element\n\t\t\tparent = env.element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\t\tparent.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tif (!env.code) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (!env.grammar) {\n\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tinsertHighlightedCode(evt.data);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Low-level function, only use if you know what youre doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tif (!env.grammar) {\n\t\t\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t\t\t}\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\t_self.Prism = _;\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _;\n\t\t}\n\n\t\tif (!_.disableWorkerMessageHandler) {\n\t\t\t// In worker\n\t\t\t_self.addEventListener('message', function (evt) {\n\t\t\t\tvar message = JSON.parse(evt.data);\n\t\t\t\tvar lang = message.language;\n\t\t\t\tvar code = message.code;\n\t\t\t\tvar immediateClose = message.immediateClose;\n\n\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\t\tif (immediateClose) {\n\t\t\t\t\t_self.close();\n\t\t\t\t}\n\t\t\t}, false);\n\t\t}\n\n\t\treturn _;\n\t}\n\n\t// Get current script and highlight\n\tvar script = _.util.currentScript();\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (script.hasAttribute('data-manual')) {\n\t\t\t_.manual = true;\n\t\t}\n\t}\n\n\tfunction highlightAutomaticallyCallback() {\n\t\tif (!_.manual) {\n\t\t\t_.highlightAll();\n\t\t}\n\t}\n\n\tif (!_.manual) {\n\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t\t// See https://github.com/PrismJS/prism/issues/2102\n\t\tvar readyState = document.readyState;\n\t\tif (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n\t\t} else {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(highlightAutomaticallyCallback);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(highlightAutomaticallyCallback, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _;\n\n}(_self));\n\nif ( true && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof __webpack_require__.g !== 'undefined') {\n\t__webpack_require__.g.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-core.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-css.js":
/*!******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-css.js ***!
  \******************************************************/
/***/ (() => {

eval("(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-css.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-javascript.js":
/*!*************************************************************!*\
  !*** ./node_modules/prismjs/components/prism-javascript.js ***!
  \*************************************************************/
/***/ (() => {

eval("Prism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-javascript.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-markdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-markdown.js ***!
  \***********************************************************/
/***/ (() => {

eval("(function (Prism) {\n\n\t// Allow only one line break\n\tvar inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n\n\t/**\n\t * This function is intended for the creation of the bold or italic pattern.\n\t *\n\t * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n\t *\n\t * _Note:_ Keep in mind that this adds a capturing group.\n\t *\n\t * @param {string} pattern\n\t * @returns {RegExp}\n\t */\n\tfunction createInline(pattern) {\n\t\tpattern = pattern.replace(/<inner>/g, function () { return inner; });\n\t\treturn RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')');\n\t}\n\n\n\tvar tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n\tvar tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function () { return tableCell; });\n\tvar tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n\n\n\tPrism.languages.markdown = Prism.languages.extend('markup', {});\n\tPrism.languages.insertBefore('markdown', 'prolog', {\n\t\t'front-matter-block': {\n\t\t\tpattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^---|---$/,\n\t\t\t\t'front-matter': {\n\t\t\t\t\tpattern: /\\S+(?:\\s+\\S+)*/,\n\t\t\t\t\talias: ['yaml', 'language-yaml'],\n\t\t\t\t\tinside: Prism.languages.yaml\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'blockquote': {\n\t\t\t// > ...\n\t\t\tpattern: /^>(?:[\\t ]*>)*/m,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'table': {\n\t\t\tpattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),\n\t\t\tinside: {\n\t\t\t\t'table-data-rows': {\n\t\t\t\t\tpattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'table-data': {\n\t\t\t\t\t\t\tpattern: RegExp(tableCell),\n\t\t\t\t\t\t\tinside: Prism.languages.markdown\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /\\|/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'table-line': {\n\t\t\t\t\tpattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /\\||:?-{3,}:?/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'table-header-row': {\n\t\t\t\t\tpattern: RegExp('^' + tableRow + '$'),\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'table-header': {\n\t\t\t\t\t\t\tpattern: RegExp(tableCell),\n\t\t\t\t\t\t\talias: 'important',\n\t\t\t\t\t\t\tinside: Prism.languages.markdown\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /\\|/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'code': [\n\t\t\t{\n\t\t\t\t// Prefixed by 4 spaces or 1 tab and preceded by an empty line\n\t\t\t\tpattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t{\n\t\t\t\t// ```optional language\n\t\t\t\t// code block\n\t\t\t\t// ```\n\t\t\t\tpattern: /^```[\\s\\S]*?^```$/m,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'code-block': {\n\t\t\t\t\t\tpattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'code-language': {\n\t\t\t\t\t\tpattern: /^(```).+/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'punctuation': /```/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'title': [\n\t\t\t{\n\t\t\t\t// title 1\n\t\t\t\t// =======\n\n\t\t\t\t// title 2\n\t\t\t\t// -------\n\t\t\t\tpattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /==+$|--+$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t// # title 1\n\t\t\t\t// ###### title 6\n\t\t\t\tpattern: /(^\\s*)#.+/m,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /^#+|#+$/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'hr': {\n\t\t\t// ***\n\t\t\t// ---\n\t\t\t// * * *\n\t\t\t// -----------\n\t\t\tpattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'list': {\n\t\t\t// * item\n\t\t\t// + item\n\t\t\t// - item\n\t\t\t// 1. item\n\t\t\tpattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'url-reference': {\n\t\t\t// [id]: http://example.com \"Optional title\"\n\t\t\t// [id]: http://example.com 'Optional title'\n\t\t\t// [id]: http://example.com (Optional title)\n\t\t\t// [id]: <http://example.com> \"Optional title\"\n\t\t\tpattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n\t\t\tinside: {\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /^(!?\\[)[^\\]]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n\t\t\t\t'punctuation': /^[\\[\\]!:]|[<>]/\n\t\t\t},\n\t\t\talias: 'url'\n\t\t},\n\t\t'bold': {\n\t\t\t// **strong**\n\t\t\t// __strong__\n\n\t\t\t// allow one nested instance of italic text using the same delimiter\n\t\t\tpattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^..)[\\s\\S]+(?=..$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\*\\*|__/\n\t\t\t}\n\t\t},\n\t\t'italic': {\n\t\t\t// *em*\n\t\t\t// _em_\n\n\t\t\t// allow one nested instance of bold text using the same delimiter\n\t\t\tpattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^.)[\\s\\S]+(?=.$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /[*_]/\n\t\t\t}\n\t\t},\n\t\t'strike': {\n\t\t\t// ~~strike through~~\n\t\t\t// ~strike~\n\t\t\t// eslint-disable-next-line regexp/strict\n\t\t\tpattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /~~?/\n\t\t\t}\n\t\t},\n\t\t'code-snippet': {\n\t\t\t// `code`\n\t\t\t// ``code``\n\t\t\tpattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\talias: ['code', 'keyword']\n\t\t},\n\t\t'url': {\n\t\t\t// [example](http://example.com \"Optional title\")\n\t\t\t// [example][id]\n\t\t\t// [example] [id]\n\t\t\tpattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'operator': /^!/,\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^\\[)[^\\]]+(?=\\])/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\tpattern: /(^\\]\\()[^\\s)]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n\t\t['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {\n\t\t\tif (token !== inside) {\n\t\t\t\tPrism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n\t\t\t}\n\t\t});\n\t});\n\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (env.language !== 'markdown' && env.language !== 'md') {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction walkTokens(tokens) {\n\t\t\tif (!tokens || typeof tokens === 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (token.type !== 'code') {\n\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n\t\t\t\t * is optional. But the grammar is defined so that there is only one case we have to handle:\n\t\t\t\t *\n\t\t\t\t * token.content = [\n\t\t\t\t *     <span class=\"punctuation\">```</span>,\n\t\t\t\t *     <span class=\"code-language\">xxxx</span>,\n\t\t\t\t *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n\t\t\t\t *     <span class=\"code-block\">...</span>,\n\t\t\t\t *     '\\n', // exactly one new lines again\n\t\t\t\t *     <span class=\"punctuation\">```</span>\n\t\t\t\t * ];\n\t\t\t\t */\n\n\t\t\t\tvar codeLang = token.content[1];\n\t\t\t\tvar codeBlock = token.content[3];\n\n\t\t\t\tif (codeLang && codeBlock &&\n\t\t\t\t\tcodeLang.type === 'code-language' && codeBlock.type === 'code-block' &&\n\t\t\t\t\ttypeof codeLang.content === 'string') {\n\n\t\t\t\t\t// this might be a language that Prism does not support\n\n\t\t\t\t\t// do some replacements to support C++, C#, and F#\n\t\t\t\t\tvar lang = codeLang.content.replace(/\\b#/g, 'sharp').replace(/\\b\\+\\+/g, 'pp');\n\t\t\t\t\t// only use the first word\n\t\t\t\t\tlang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase();\n\t\t\t\t\tvar alias = 'language-' + lang;\n\n\t\t\t\t\t// add alias\n\t\t\t\t\tif (!codeBlock.alias) {\n\t\t\t\t\t\tcodeBlock.alias = [alias];\n\t\t\t\t\t} else if (typeof codeBlock.alias === 'string') {\n\t\t\t\t\t\tcodeBlock.alias = [codeBlock.alias, alias];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcodeBlock.alias.push(alias);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twalkTokens(env.tokens);\n\t});\n\n\tPrism.hooks.add('wrap', function (env) {\n\t\tif (env.type !== 'code-block') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar codeLang = '';\n\t\tfor (var i = 0, l = env.classes.length; i < l; i++) {\n\t\t\tvar cls = env.classes[i];\n\t\t\tvar match = /language-(.+)/.exec(cls);\n\t\t\tif (match) {\n\t\t\t\tcodeLang = match[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar grammar = Prism.languages[codeLang];\n\n\t\tif (!grammar) {\n\t\t\tif (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n\t\t\t\tvar id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);\n\t\t\t\tenv.attributes['id'] = id;\n\n\t\t\t\tPrism.plugins.autoloader.loadLanguages(codeLang, function () {\n\t\t\t\t\tvar ele = document.getElementById(id);\n\t\t\t\t\tif (ele) {\n\t\t\t\t\t\tele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tenv.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n\t\t}\n\t});\n\n\tvar tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');\n\n\t/**\n\t * A list of known entity names.\n\t *\n\t * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n\t *\n\t * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n\t */\n\tvar KNOWN_ENTITY_NAMES = {\n\t\t'amp': '&',\n\t\t'lt': '<',\n\t\t'gt': '>',\n\t\t'quot': '\"',\n\t};\n\n\t// IE 11 doesn't support `String.fromCodePoint`\n\tvar fromCodePoint = String.fromCodePoint || String.fromCharCode;\n\n\t/**\n\t * Returns the text content of a given HTML source code string.\n\t *\n\t * @param {string} html\n\t * @returns {string}\n\t */\n\tfunction textContent(html) {\n\t\t// remove all tags\n\t\tvar text = html.replace(tagPattern, '');\n\n\t\t// decode known entities\n\t\ttext = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n\t\t\tcode = code.toLowerCase();\n\n\t\t\tif (code[0] === '#') {\n\t\t\t\tvar value;\n\t\t\t\tif (code[1] === 'x') {\n\t\t\t\t\tvalue = parseInt(code.slice(2), 16);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = Number(code.slice(1));\n\t\t\t\t}\n\n\t\t\t\treturn fromCodePoint(value);\n\t\t\t} else {\n\t\t\t\tvar known = KNOWN_ENTITY_NAMES[code];\n\t\t\t\tif (known) {\n\t\t\t\t\treturn known;\n\t\t\t\t}\n\n\t\t\t\t// unable to decode\n\t\t\t\treturn m;\n\t\t\t}\n\t\t});\n\n\t\treturn text;\n\t}\n\n\tPrism.languages.md = Prism.languages.markdown;\n\n}(Prism));\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-markdown.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-markup.js":
/*!*********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-markup.js ***!
  \*********************************************************/
/***/ (() => {

eval("Prism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-markup.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-objectivec.js":
/*!*************************************************************!*\
  !*** ./node_modules/prismjs/components/prism-objectivec.js ***!
  \*************************************************************/
/***/ (() => {

eval("Prism.languages.objectivec = Prism.languages.extend('c', {\n\t'string': {\n\t\tpattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'keyword': /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n\t'operator': /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\n\ndelete Prism.languages.objectivec['class-name'];\n\nPrism.languages.objc = Prism.languages.objectivec;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-objectivec.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-python.js":
/*!*********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-python.js ***!
  \*********************************************************/
/***/ (() => {

eval("Prism.languages.python = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])#.*/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string-interpolation': {\n\t\tpattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\t// \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n\t\t\t\tpattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'format-spec': {\n\t\t\t\t\t\tpattern: /(:)[^:(){}]+(?=\\}$)/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'conversion-option': {\n\t\t\t\t\t\tpattern: /![sra](?=[:}]$)/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: null\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'triple-quoted-string': {\n\t\tpattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n\t\tgreedy: true,\n\t\talias: 'string'\n\t},\n\t'string': {\n\t\tpattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n\t\tgreedy: true\n\t},\n\t'function': {\n\t\tpattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n\t\tlookbehind: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\bclass\\s+)\\w+/i,\n\t\tlookbehind: true\n\t},\n\t'decorator': {\n\t\tpattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n\t\tlookbehind: true,\n\t\talias: ['annotation', 'punctuation'],\n\t\tinside: {\n\t\t\t'punctuation': /\\./\n\t\t}\n\t},\n\t'keyword': /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n\t'builtin': /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n\t'boolean': /\\b(?:False|None|True)\\b/,\n\t'number': /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n\t'operator': /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\nPrism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;\n\nPrism.languages.py = Prism.languages.python;\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-python.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-rust.js":
/*!*******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-rust.js ***!
  \*******************************************************/
/***/ (() => {

eval("(function (Prism) {\n\n\tvar multilineComment = /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source;\n\tfor (var i = 0; i < 2; i++) {\n\t\t// support 4 levels of nested comments\n\t\tmultilineComment = multilineComment.replace(/<self>/g, function () { return multilineComment; });\n\t}\n\tmultilineComment = multilineComment.replace(/<self>/g, function () { return /[^\\s\\S]/.source; });\n\n\n\tPrism.languages.rust = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(^|[^\\\\])/.source + multilineComment),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t}\n\t\t],\n\t\t'string': {\n\t\t\tpattern: /b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'char': {\n\t\t\tpattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'attribute': {\n\t\t\tpattern: /#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,\n\t\t\tgreedy: true,\n\t\t\talias: 'attr-name',\n\t\t\tinside: {\n\t\t\t\t'string': null // see below\n\t\t\t}\n\t\t},\n\n\t\t// Closure params should not be confused with bitwise OR |\n\t\t'closure-params': {\n\t\t\tpattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'closure-punctuation': {\n\t\t\t\t\tpattern: /^\\||\\|$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: null // see below\n\t\t\t}\n\t\t},\n\n\t\t'lifetime-annotation': {\n\t\t\tpattern: /'\\w+/,\n\t\t\talias: 'symbol'\n\t\t},\n\n\t\t'fragment-specifier': {\n\t\t\tpattern: /(\\$\\w+:)[a-z]+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'variable': /\\$\\w+/,\n\n\t\t'function-definition': {\n\t\t\tpattern: /(\\bfn\\s+)\\w+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function'\n\t\t},\n\t\t'type-definition': {\n\t\t\tpattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'class-name'\n\t\t},\n\t\t'module-declaration': [\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'namespace'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'namespace',\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /::/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'keyword': [\n\t\t\t// https://github.com/rust-lang/reference/blob/master/src/keywords.md\n\t\t\t/\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n\t\t\t// primitives and str\n\t\t\t// https://doc.rust-lang.org/stable/rust-by-example/primitives.html\n\t\t\t/\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/\n\t\t],\n\n\t\t// functions can technically start with an upper-case letter, but this will introduce a lot of false positives\n\t\t// and Rust's naming conventions recommend snake_case anyway.\n\t\t// https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\n\t\t'function': /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n\t\t'macro': {\n\t\t\tpattern: /\\b\\w+!/,\n\t\t\talias: 'property'\n\t\t},\n\t\t'constant': /\\b[A-Z_][A-Z_\\d]+\\b/,\n\t\t'class-name': /\\b[A-Z]\\w*\\b/,\n\n\t\t'namespace': {\n\t\t\tpattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /::/\n\t\t\t}\n\t\t},\n\n\t\t// Hex, oct, bin, dec numbers with visual separators and type suffix\n\t\t'number': /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t'punctuation': /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n\t\t'operator': /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n\t};\n\n\tPrism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;\n\tPrism.languages.rust['attribute'].inside['string'] = Prism.languages.rust['string'];\n\n}(Prism));\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-rust.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-sql.js":
/*!******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-sql.js ***!
  \******************************************************/
/***/ (() => {

eval("Prism.languages.sql = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n\t\tlookbehind: true\n\t},\n\t'variable': [\n\t\t{\n\t\t\tpattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t/@[\\w.$]+/\n\t],\n\t'string': {\n\t\tpattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n\t\tgreedy: true,\n\t\tlookbehind: true\n\t},\n\t'identifier': {\n\t\tpattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n\t\tgreedy: true,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^`|`$/\n\t\t}\n\t},\n\t'function': /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i, // Should we highlight user defined functions too?\n\t'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n\t'boolean': /\\b(?:FALSE|NULL|TRUE)\\b/i,\n\t'number': /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n\t'operator': /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n\t'punctuation': /[;[\\]()`,.]/\n};\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-sql.js?");

/***/ }),

/***/ "./node_modules/prismjs/components/prism-swift.js":
/*!********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-swift.js ***!
  \********************************************************/
/***/ (() => {

eval("Prism.languages.swift = {\n\t'comment': {\n\t\t// Nested comments are supported up to 2 levels\n\t\tpattern: /(^|[^\\\\:])(?:\\/\\/.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*\\*\\/)/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string-literal': [\n\t\t// https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[^\"#])/.source\n\t\t\t\t+ '(?:'\n\t\t\t\t// single-line string\n\t\t\t\t+ /\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^(])|[^\\\\\\r\\n\"])*\"/.source\n\t\t\t\t+ '|'\n\t\t\t\t// multi-line string\n\t\t\t\t+ /\"\"\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|[^(])|[^\\\\\"]|\"(?!\"\"))*\"\"\"/.source\n\t\t\t\t+ ')'\n\t\t\t\t+ /(?![\"#])/.source\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /(\\\\\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: null // see below\n\t\t\t\t},\n\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\tpattern: /^\\)|\\\\\\($/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\\\(?=[\\r\\n])/,\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[^\"#])(#+)/.source\n\t\t\t\t+ '(?:'\n\t\t\t\t// single-line string\n\t\t\t\t+ /\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^#])|[^\\\\\\r\\n])*?\"/.source\n\t\t\t\t+ '|'\n\t\t\t\t// multi-line string\n\t\t\t\t+ /\"\"\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|[^#])|[^\\\\])*?\"\"\"/.source\n\t\t\t\t+ ')'\n\t\t\t\t+ '\\\\2'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /(\\\\#+\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: null // see below\n\t\t\t\t},\n\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\tpattern: /^\\)|\\\\#+\\($/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t],\n\n\t'directive': {\n\t\t// directives with conditions\n\t\tpattern: RegExp(\n\t\t\t/#/.source\n\t\t\t+ '(?:'\n\t\t\t+ (\n\t\t\t\t/(?:elseif|if)\\b/.source\n\t\t\t\t+ '(?:[ \\t]*'\n\t\t\t\t// This regex is a little complex. It's equivalent to this:\n\t\t\t\t//   (?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*<round>)?|<round>)(?:[ \\t]*(?:&&|\\|\\|))?\n\t\t\t\t// where <round> is a general parentheses expression.\n\t\t\t\t+ /(?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*\\((?:[^()]|\\([^()]*\\))*\\))?|\\((?:[^()]|\\([^()]*\\))*\\))(?:[ \\t]*(?:&&|\\|\\|))?/.source\n\t\t\t\t+ ')+'\n\t\t\t)\n\t\t\t+ '|'\n\t\t\t+ /(?:else|endif)\\b/.source\n\t\t\t+ ')'\n\t\t),\n\t\talias: 'property',\n\t\tinside: {\n\t\t\t'directive-name': /^#\\w+/,\n\t\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t\t'number': /\\b\\d+(?:\\.\\d+)*\\b/,\n\t\t\t'operator': /!|&&|\\|\\||[<>]=?/,\n\t\t\t'punctuation': /[(),]/\n\t\t}\n\t},\n\t'literal': {\n\t\tpattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\\b/,\n\t\talias: 'constant'\n\t},\n\t'other-directive': {\n\t\tpattern: /#\\w+\\b/,\n\t\talias: 'property'\n\t},\n\n\t'attribute': {\n\t\tpattern: /@\\w+/,\n\t\talias: 'atrule'\n\t},\n\n\t'function-definition': {\n\t\tpattern: /(\\bfunc\\s+)\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'label': {\n\t\t// https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141\n\t\tpattern: /\\b(break|continue)\\s+\\w+|\\b[a-zA-Z_]\\w*(?=\\s*:\\s*(?:for|repeat|while)\\b)/,\n\t\tlookbehind: true,\n\t\talias: 'important'\n\t},\n\n\t'keyword': /\\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'nil': {\n\t\tpattern: /\\bnil\\b/,\n\t\talias: 'constant'\n\t},\n\n\t'short-argument': /\\$\\d+\\b/,\n\t'omit': {\n\t\tpattern: /\\b_\\b/,\n\t\talias: 'keyword'\n\t},\n\t'number': /\\b(?:[\\d_]+(?:\\.[\\de_]+)?|0x[a-f0-9_]+(?:\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n\n\t// A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.\n\t'class-name': /\\b[A-Z](?:[A-Z_\\d]*[a-z]\\w*)?\\b/,\n\t'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n\t'constant': /\\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n\n\t// Operators are generic in Swift. Developers can even create new operators (e.g. +++).\n\t// https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481\n\t// This regex only supports ASCII operators.\n\t'operator': /[-+*/%=!<>&|^~?]+|\\.[.\\-+*/%=!<>&|^~?]+/,\n\t'punctuation': /[{}[\\]();,.:\\\\]/\n};\n\nPrism.languages.swift['string-literal'].forEach(function (rule) {\n\trule.inside['interpolation'].inside = Prism.languages.swift;\n});\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/prismjs/components/prism-swift.js?");

/***/ }),

/***/ "./src/Beeeditor/styles.css":
/*!**********************************!*\
  !*** ./src/Beeeditor/styles.css ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/Beeeditor/styles.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./src/Beeeditor/styles.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://@fantufantu/beeeditor/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});